From 9d2260a0e0fae9132206d2ff93378d3630743251 Mon Sep 17 00:00:00 2001
From: Peter Goodman <peter.goodman@gmail.com>
Date: Thu, 20 Apr 2023 00:23:41 -0400
Subject: [PATCH] Patches for PASTA.

---
 clang/include/clang/Basic/TokenKinds.def      |   7 +
 clang/include/clang/Lex/PPCallbacks.h         |  14 +
 .../include/clang/Lex/PPCallbacksEventKind.h  | 168 +++++++++++
 clang/include/clang/Lex/Preprocessor.h        |  46 ++-
 clang/include/clang/Lex/TokenLexer.h          |   7 +-
 clang/lib/AST/ASTContext.cpp                  | 130 +++++++--
 clang/lib/AST/ExprConstant.cpp                |   9 +
 clang/lib/AST/ItaniumMangle.cpp               |   8 +
 clang/lib/AST/Type.cpp                        |   9 +-
 clang/lib/Lex/Lexer.cpp                       |   9 +
 clang/lib/Lex/PPDirectives.cpp                | 148 +++++++---
 clang/lib/Lex/PPExpressions.cpp               |  29 ++
 clang/lib/Lex/PPLexerChange.cpp               |  39 +++
 clang/lib/Lex/PPMacroExpansion.cpp            | 268 +++++++++++++++++-
 clang/lib/Lex/Pragma.cpp                      |  76 ++++-
 clang/lib/Lex/Preprocessor.cpp                |  44 ++-
 clang/lib/Lex/TokenLexer.cpp                  | 226 ++++++++++++++-
 clang/lib/Parse/ParseExpr.cpp                 |  32 ++-
 clang/lib/Parse/ParseTemplate.cpp             |   8 +
 clang/lib/Sema/SemaDecl.cpp                   |  12 +
 clang/lib/Sema/SemaExpr.cpp                   |  32 ++-
 clang/lib/Sema/SemaExprCXX.cpp                |   1 +
 clang/lib/Sema/TreeTransform.h                |  24 ++
 23 files changed, 1223 insertions(+), 123 deletions(-)
 create mode 100644 clang/include/clang/Lex/PPCallbacksEventKind.h

diff --git a/clang/include/clang/Basic/TokenKinds.def b/clang/include/clang/Basic/TokenKinds.def
index 96feae991..0fa2f84d5 100644
--- a/clang/include/clang/Basic/TokenKinds.def
+++ b/clang/include/clang/Basic/TokenKinds.def
@@ -565,6 +565,13 @@ ALIAS("__is_same_as", __is_same, KEYCXX)
 KEYWORD(__private_extern__          , KEYALL)
 KEYWORD(__module_private__          , KEYALL)
 
+// PASTA PATCH: Apple-specific XNU extensions.
+UNARY_EXPR_OR_TYPE_TRAIT(__builtin_ptrauth_type_discriminator, PtrAuthTypeDiscriminator, KEYALL)
+UNARY_EXPR_OR_TYPE_TRAIT(__builtin_xnu_type_signature, XNUTypeSignature, KEYALL)
+UNARY_EXPR_OR_TYPE_TRAIT(__builtin_xnu_type_summary, XNUTypeSummary, KEYALL)
+UNARY_EXPR_OR_TYPE_TRAIT(__builtin_tmo_type_get_metadata, TMOTypeGetMetadata, KEYALL)
+TYPE_TRAIT_2(__builtin_xnu_types_compatible, XNUTypeCompatible, KEYALL)
+
 // Extension that will be enabled for Microsoft, Borland and PS4, but can be
 // disabled via '-fno-declspec'.
 KEYWORD(__declspec                  , 0)
diff --git a/clang/include/clang/Lex/PPCallbacks.h b/clang/include/clang/Lex/PPCallbacks.h
index 94f96cf9c..c7b5b7d4b 100644
--- a/clang/include/clang/Lex/PPCallbacks.h
+++ b/clang/include/clang/Lex/PPCallbacks.h
@@ -40,6 +40,14 @@ public:
     EnterFile, ExitFile, SystemHeaderPragma, RenameFile
   };
 
+  // PASTA PATCH: Add in an event that lets us get better visibility into the
+  //              behavior of the preprocessor, as things are happening.
+#define LLVM_CLANG_HAS_PASTA_EVENTS 20230322L
+  enum EventKind : int;
+
+  // PASTA PATCH:
+  virtual void Event(const Token &Tok, EventKind Kind, uintptr_t Data) {}
+
   /// Callback invoked whenever a source file is entered or exited.
   ///
   /// \param Loc Indicates the new location.
@@ -441,6 +449,12 @@ public:
 
   ~PPChainedCallbacks() override;
 
+  // PASTA PATCH
+  void Event(const Token &Tok, EventKind Kind, uintptr_t Data) override {
+    First->Event(Tok, Kind, Data);
+    Second->Event(Tok, Kind, Data);
+  }
+
   void FileChanged(SourceLocation Loc, FileChangeReason Reason,
                    SrcMgr::CharacteristicKind FileType,
                    FileID PrevFID) override {
diff --git a/clang/include/clang/Lex/PPCallbacksEventKind.h b/clang/include/clang/Lex/PPCallbacksEventKind.h
new file mode 100644
index 000000000..4f399f9c9
--- /dev/null
+++ b/clang/include/clang/Lex/PPCallbacksEventKind.h
@@ -0,0 +1,168 @@
+// Copyright (c) 2023-present, Trail of Bits, Inc.
+// All rights reserved.
+//
+// This source code is licensed in accordance with the terms specified in
+// the LICENSE.TXT file found in the root directory of this source tree.
+
+#pragma once
+
+#include "PPCallbacks.h"
+
+namespace clang {
+
+enum PPCallbacks::EventKind : int {
+  // Tell us just after one of the lexers has lexed a token.
+  //
+  // `Tok` is the token generated from one of the underlying lexers.
+  // `Data` is zero or it is a raw source location for where the lexer was
+  // invoked.
+  TokenFromLexer,
+  TokenFromTokenLexer,
+  TokenFromCachingLexer,
+  TokenFromAfterModuleImportLexer,
+
+  // Tell the listener that the parser has split a token. This happens in C++
+  // code for templates, e.g. `constant<bar<A>>>0`, where the `>>>` is first
+  // treated as one token, but then where the parser realizes that it is
+  // really `constant<bar<A>> > 0`.
+  BeginSplitToken,
+  EndSplitToken,
+
+  // Tell the listener that we've just lexed the hash token that should start
+  // off a directive.
+  //
+  // `Tok` is the `#`.
+  BeginDirective,
+
+  // Ends with an `EndDirective`.
+  //
+  // `Tok` is the `#`.
+  BeginSkippedArea,
+
+  // Tell the listener that we're in a named directive, e.g. `if` or `define`.
+  //
+  // `Tok` is the `#`.
+  // `Data` is a `Token *` of the token lexed after the `#`.
+  SetNamedDirective,
+
+  // Tell the listener that we're in an unnamed directive, e.g. GNU line
+  // numbers, such as `# 1`.
+  //
+  // `Tok` is the `#`.
+  // `Data` is a `const Token *` of the token lexed after the `#`.
+  SetUnnamedDirective,
+
+  // End a directive.
+  //
+  // `Tok` is the `tok::eod` token.
+  EndDirective,
+
+  // We thought something was a directive, but it wasn't, e.g. due to us
+  // parsing a .S file.
+  EndNonDirective,
+
+  // `Tok` is the name of the macro being expanded.
+  // `Data` is the `MacroInfo *`. For built-in macros, this may be `nullptr`.
+  BeginMacroExpansion,
+  SwitchToExpansion,
+  BeginPreArgumentExpansion,
+  EndPreArgumentExpansion,
+  PrepareToCancelExpansion,  // E.g. `_Pragma` in macro argument pre-exansion.
+  CancelExpansion,  // E.g. `_Pragma` in a macro parameter.
+  EndMacroExpansion,
+
+  // `Tok` is the name of the macro being expanded.
+  // `Data` is a `MacroInfo *`.
+  BeginMacroCallArgumentList,
+
+  // `Tok` is the token that terminated the argument list, i.e. a `)`.
+  // `Data` is a `MacroArgs *`. For built-in macros, this may be `nullptr`.
+  EndMacroCallArgumentList,
+
+  // `Tok` is the token just before the first token of the argument, e.g.
+  // `(` or `,`.
+  // `Data` is a `Token *` of the macro name.
+  BeginMacroCallArgument,
+
+  // `Tok` is the token just before the first token of the argument.
+  // `Data` is a `Token *` just after the last token of the argument, e.g. a
+  // `)` or a `,`.
+  EndMacroCallArgument,
+
+  // `Tok` is the token just before the first token of the variadic arguments,
+  // e.g. a `(` or a `,`.
+  // `Data` is a `Token *` of the macro name.
+  BeginVariadicCallArgumentList,
+
+  // `Tok` is the token just before the first token of the variadic arguments
+  // `Data` is a `Token *` just after the last token of the arguments, e.g. a
+  // `)` or a `,`.
+  EndVariadicCallArgumentList,
+
+  // `Tok` is the token which begins the substitution.
+  // `Data` is `nullptr`.
+  BeginSubstitution,
+
+  // `Tok` is the token (previously visible via another event) which we want
+  // to say begins the substitution.
+  // `Data` is `nullptr`.
+  BeginDelayedSubstitution,
+
+  // `Tok` is the last token before the substituted tokens will begin being
+  // outputted.
+  // `Data` is a `Token *` of the first token of the substitution.
+  SwitchToSubstitution,
+
+  // `Tok` is the last substituted token.
+  // `Data` is a `Token *` of the first token of the substitution.
+  EndSubstitution,
+
+  // `Tok` is the token (possibly previously visible via another event) which
+  // is about to be pasted with something else.
+  // `Data` is a `Token *` of the `##` token.
+  BeginConcatenation,
+  EndConcatenation,
+
+  // `Tok` is a `##` for concatenation.
+  // `Data` is a `Token *` of the token into which the right hand side of the
+  // `##` is being concatenated.
+  ConcatenationOperatorToken,
+
+  // `Tok` is a right hand side for concatenation.
+  // `Data` is a `Token *` of the token into which `Tok` is being concatenated.
+  ConcatenationAccumulationToken,
+
+  // `Tok` is the first output token in the intermediate results buffer.
+  // `Data` is the number of tokens in the buffer.
+  //
+  // NOTE(pag): Before/After concatenation don't actually show us the resulting
+  //            pasted token. Instead, that is done in `TokenLexer::Lex`, as it
+  //            is reading from the resulting tokens. To observe the
+  //            concatenation, use `BeginConcatenation` and `EndConcatenation`.
+  BeforeParameterSubstitutions,
+  AfterParameterSubstitutions,
+  BeforeVAOpt,
+  AfterVAOpt,
+  BeforeStringify,
+  AfterStringify,
+  BeforeConcatenation,
+  AfterConcatenation,
+  BeforeMacroParameterUse,
+  AfterMacroParameterUse,
+  BeforeRemoveCommas,
+  AfterRemoveCommas,
+
+  // `Tok` is the token inside of a `__VA_OPT__` that is being skipped if
+  // `__VA_ARGS__` is empty. `Data` is zero.
+  SkippedVAOptToken,
+
+  // // `Tok` is a special token elided from a macro definition body, e.g.
+  // // `#` before a parameter name.
+  // // `Data` is a `MacroInfo *`.
+  // ElidedTokenInDefinitionBody,
+
+  // // `Tok` is a token in the body.
+  // TokenInDefinitionBody,
+};
+
+}  // namespace clang
diff --git a/clang/include/clang/Lex/Preprocessor.h b/clang/include/clang/Lex/Preprocessor.h
index 322626802..72f23ebab 100644
--- a/clang/include/clang/Lex/Preprocessor.h
+++ b/clang/include/clang/Lex/Preprocessor.h
@@ -790,6 +790,9 @@ private:
   /// encountered (e.g. a file is \#included, etc).
   std::unique_ptr<PPCallbacks> Callbacks;
 
+  // PASTA PATCH: Add post-lex action.
+  std::function<void(const Token &)> PostLexAction;
+
   struct MacroExpandsInfo {
     Token Tok;
     MacroDefinition MD;
@@ -1624,8 +1627,8 @@ public:
 
   /// Process directives while skipping until the through header or
   /// #pragma hdrstop is found.
-  void HandleSkippedDirectiveWhileUsingPCH(Token &Result,
-                                           SourceLocation HashLoc);
+  void HandleSkippedDirectiveWhileUsingPCH(Token &Result,  // PASTA PATCH
+                                           const Token &SavedHash);  // PASTA PATCH
 
   /// Enter the specified FileID as the main source file,
   /// which implicitly adds the builtin defines etc.
@@ -2434,15 +2437,7 @@ private:
     CurPPLexer = nullptr;
   }
 
-  void PopIncludeMacroStack() {
-    CurLexer = std::move(IncludeMacroStack.back().TheLexer);
-    CurPPLexer = IncludeMacroStack.back().ThePPLexer;
-    CurTokenLexer = std::move(IncludeMacroStack.back().TheTokenLexer);
-    CurDirLookup  = IncludeMacroStack.back().TheDirLookup;
-    CurLexerSubmodule = IncludeMacroStack.back().TheSubmodule;
-    CurLexerKind = IncludeMacroStack.back().CurLexerKind;
-    IncludeMacroStack.pop_back();
-  }
+  void PopIncludeMacroStack();  // PASTA PATCH
 
   void PropagateLineStartLeadingSpaceInfo(Token &Result);
 
@@ -2506,7 +2501,7 @@ private:
   /// \p FoundElse is false, then \#else directives are ok, if not, then we have
   /// already seen one so a \#else directive is a duplicate.  When this returns,
   /// the caller can lex the first valid token.
-  void SkipExcludedConditionalBlock(SourceLocation HashTokenLoc,
+  void SkipExcludedConditionalBlock(const Token &HashToken,  // PASTA PATCH
                                     SourceLocation IfTokenLoc,
                                     bool FoundNonSkipPortion, bool FoundElse,
                                     SourceLocation ElseLoc = SourceLocation());
@@ -2574,7 +2569,7 @@ private:
   /// After reading "MACRO(", this method is invoked to read all of the formal
   /// arguments specified for the macro invocation.  Returns null on error.
   MacroArgs *ReadMacroCallArgumentList(Token &MacroName, MacroInfo *MI,
-                                       SourceLocation &MacroEnd);
+                                       Token &MacroEndTok);  // PASTA PATCH
 
   /// If an identifier token is read that is to be expanded
   /// as a builtin macro, handle it and return the next token as 'Tok'.
@@ -2641,12 +2636,12 @@ private:
   /// Handle*Directive - implement the various preprocessor directives.  These
   /// should side-effect the current preprocessor object so that the next call
   /// to Lex() will return the appropriate token next.
-  void HandleLineDirective();
-  void HandleDigitDirective(Token &Tok);
-  void HandleUserDiagnosticDirective(Token &Tok, bool isWarning);
-  void HandleIdentSCCSDirective(Token &Tok);
-  void HandleMacroPublicDirective(Token &Tok);
-  void HandleMacroPrivateDirective();
+  void HandleLineDirective(const Token &SavedHash);  // PASTA PATCH
+  void HandleDigitDirective(const Token &SavedHash, Token &Tok);  // PASTA PATCH
+  void HandleUserDiagnosticDirective(const Token &SavedHash, Token &Tok, bool isWarning);  // PASTA PATCH
+  void HandleIdentSCCSDirective(const Token &SavedHash, Token &Tok);  // PASTA PATCH
+  void HandleMacroPublicDirective(const Token &SavedHash, Token &Tok);  // PASTA PATCH
+  void HandleMacroPrivateDirective(const Token &SavedHash);  // PASTA PATCH
 
   /// An additional notification that can be produced by a header inclusion or
   /// import to tell the parser what happened.
@@ -2678,7 +2673,7 @@ private:
       ModuleMap::KnownHeader &SuggestedModule, bool isAngled);
 
   // File inclusion.
-  void HandleIncludeDirective(SourceLocation HashLoc, Token &Tok,
+  void HandleIncludeDirective(const Token &SavedHash, Token &Tok,  // PASTA PATCH
                               ConstSearchDirIterator LookupFrom = nullptr,
                               const FileEntry *LookupFromFile = nullptr);
   ImportAction
@@ -2686,9 +2681,9 @@ private:
                               Token &FilenameTok, SourceLocation EndLoc,
                               ConstSearchDirIterator LookupFrom = nullptr,
                               const FileEntry *LookupFromFile = nullptr);
-  void HandleIncludeNextDirective(SourceLocation HashLoc, Token &Tok);
-  void HandleIncludeMacrosDirective(SourceLocation HashLoc, Token &Tok);
-  void HandleImportDirective(SourceLocation HashLoc, Token &Tok);
+  void HandleIncludeNextDirective(const Token &SavedHash, Token &Tok);  // PASTA PATCH
+  void HandleIncludeMacrosDirective(const Token &SavedHash, Token &Tok);  // PASTA PATCH
+  void HandleImportDirective(const Token &SavedHash, Token &Tok);  // PASTA PATCH
   void HandleMicrosoftImportDirective(Token &Tok);
 
 public:
@@ -2755,8 +2750,9 @@ private:
   void replayPreambleConditionalStack();
 
   // Macro handling.
-  void HandleDefineDirective(Token &Tok, bool ImmediatelyAfterHeaderGuard);
-  void HandleUndefDirective();
+  void HandleDefineDirective(const Token &SavedHash, Token &Tok,  // PASTA PATCH
+                             bool ImmediatelyAfterHeaderGuard);  // PASTA PATCH
+  void HandleUndefDirective(const Token &SavedHash);  // PASTA PATCH
 
   // Conditional Inclusion.
   void HandleIfdefDirective(Token &Result, const Token &HashToken,
diff --git a/clang/include/clang/Lex/TokenLexer.h b/clang/include/clang/Lex/TokenLexer.h
index 4d229ae61..923107b84 100644
--- a/clang/include/clang/Lex/TokenLexer.h
+++ b/clang/include/clang/Lex/TokenLexer.h
@@ -13,7 +13,7 @@
 #ifndef LLVM_CLANG_LEX_TOKENLEXER_H
 #define LLVM_CLANG_LEX_TOKENLEXER_H
 
-#include "clang/Basic/SourceLocation.h"
+#include "clang/Lex/Token.h"  // PASTA PATCH
 #include "llvm/ADT/ArrayRef.h"
 
 namespace clang {
@@ -40,6 +40,9 @@ class TokenLexer {
   /// The current preprocessor object we are expanding for.
   Preprocessor &PP;
 
+  // PASTA PATCH: The name token of the macro.
+  Token MacroNameTok;
+
   /// This is the pointer to an array of tokens that the macro is
   /// defined to, with arguments expanded for function-like macros.  If this is
   /// a token stream, these are the tokens we are returning.  This points into
@@ -98,7 +101,7 @@ class TokenLexer {
 
   /// When true, the produced tokens have Token::IsReinjected flag set.
   /// See the flag documentation for details.
-  bool IsReinject : 1;
+  bool IsReinject;  // PASTA PATCH
 
 public:
   /// Create a TokenLexer for the specified macro with the specified actual
diff --git a/clang/lib/AST/ASTContext.cpp b/clang/lib/AST/ASTContext.cpp
index 2884fe660..660887abc 100644
--- a/clang/lib/AST/ASTContext.cpp
+++ b/clang/lib/AST/ASTContext.cpp
@@ -3545,49 +3545,99 @@ QualType ASTContext::getConstantArrayType(QualType EltTy,
           EltTy->isIncompleteType() || EltTy->isConstantSizeType()) &&
          "Constant array of VLAs is illegal!");
 
-  // We only need the size as part of the type if it's instantiation-dependent.
-  if (SizeExpr && !SizeExpr->isInstantiationDependent())
-    SizeExpr = nullptr;
-
   // Convert the array size into a canonical width matching the pointer size for
   // the target.
   llvm::APInt ArySize(ArySizeIn);
   ArySize = ArySize.zextOrTrunc(Target->getMaxPointerWidth());
 
+  // PASTA PATCH: Make it always retain `SizeExpr` so that we can see token
+  //              provenance for arrays whose types are the result of some
+  //              expression.
+  const Expr *OrigSizeExpr = SizeExpr;
+  if (SizeExpr && !SizeExpr->isInstantiationDependent() &&
+      !isa<ConstantExpr>(SizeExpr) && !isa<IntegerLiteral>(SizeExpr)) {
+    llvm::APSInt ArySizeInt(ArySizeIn, !ArySizeIn.isNegative());
+    OrigSizeExpr = ConstantExpr::Create(
+        *this, const_cast<Expr *>(SizeExpr), clang::APValue(ArySizeInt));
+  }
+
+  // We only need the size as part of the type if it's instantiation-dependent.
+  if (SizeExpr && !SizeExpr->isInstantiationDependent())
+    SizeExpr = nullptr;
+
   llvm::FoldingSetNodeID ID;
   ConstantArrayType::Profile(ID, *this, EltTy, ArySize, SizeExpr, ASM,
                              IndexTypeQuals);
 
   void *InsertPos = nullptr;
-  if (ConstantArrayType *ATP =
-      ConstantArrayTypes.FindNodeOrInsertPos(ID, InsertPos))
+  ConstantArrayType *ATP =
+      ConstantArrayTypes.FindNodeOrInsertPos(ID, InsertPos);
+
+  // PASTA PATCH: Profile the original one. In practice, we should probably
+  //              never have a cache hit.
+  llvm::FoldingSetNodeID OrigID;
+  void *OrigInsertPos = nullptr;
+  ConstantArrayType *OrigATP = nullptr;
+  if (OrigSizeExpr) {
+    ConstantArrayType::Profile(OrigID, *this, EltTy, ArySize, OrigSizeExpr, ASM,
+                               IndexTypeQuals);
+    OrigATP = ConstantArrayTypes.FindNodeOrInsertPos(OrigID, OrigInsertPos);
+  }
+
+  if (ATP && OrigATP)
+    return getAdjustedType(QualType(OrigATP, 0), QualType(ATP, 0));
+
+  if (!OrigSizeExpr && ATP)
     return QualType(ATP, 0);
 
-  // If the element type isn't canonical or has qualifiers, or the array bound
-  // is instantiation-dependent, this won't be a canonical type either, so fill
-  // in the canonical type field.
-  QualType Canon;
-  // FIXME: Check below should look for qualifiers behind sugar.
-  if (!EltTy.isCanonical() || EltTy.hasLocalQualifiers() || SizeExpr) {
-    SplitQualType canonSplit = getCanonicalType(EltTy).split();
-    Canon = getConstantArrayType(QualType(canonSplit.Ty, 0), ArySize, nullptr,
-                                 ASM, IndexTypeQuals);
-    Canon = getQualifiedType(Canon, canonSplit.Quals);
+  if (!ATP) {
+    // If the element type isn't canonical or has qualifiers, or the array bound
+    // is instantiation-dependent, this won't be a canonical type either, so fill
+    // in the canonical type field.
+    QualType Canon;
+    // FIXME: Check below should look for qualifiers behind sugar.
+    if (!EltTy.isCanonical() || EltTy.hasLocalQualifiers() || SizeExpr) {
+      SplitQualType canonSplit = getCanonicalType(EltTy).split();
+      Canon = getConstantArrayType(QualType(canonSplit.Ty, 0), ArySize, nullptr,
+                                   ASM, IndexTypeQuals);
+      Canon = getQualifiedType(Canon, canonSplit.Quals);
 
-    // Get the new insert position for the node we care about.
-    ConstantArrayType *NewIP =
-      ConstantArrayTypes.FindNodeOrInsertPos(ID, InsertPos);
-    assert(!NewIP && "Shouldn't be in the map!"); (void)NewIP;
+      // Get the new insert position for the node we care about.
+      ConstantArrayType *NewIP =
+        ConstantArrayTypes.FindNodeOrInsertPos(ID, InsertPos);
+      assert(!NewIP && "Shouldn't be in the map!"); (void)NewIP;
+
+      // TODO(pag): Calculate a new insert position for orig expressions?
+    }
+
+    void *Mem = Allocate(
+        ConstantArrayType::totalSizeToAlloc<const Expr *>(SizeExpr ? 1 : 0),
+        TypeAlignment);
+    ATP = new (Mem)
+      ConstantArrayType(EltTy, Canon, ArySize, SizeExpr, ASM, IndexTypeQuals);
+    ConstantArrayTypes.InsertNode(ATP, InsertPos);
+    Types.push_back(ATP);
   }
 
-  void *Mem = Allocate(
-      ConstantArrayType::totalSizeToAlloc<const Expr *>(SizeExpr ? 1 : 0),
-      TypeAlignment);
-  auto *New = new (Mem)
-    ConstantArrayType(EltTy, Canon, ArySize, SizeExpr, ASM, IndexTypeQuals);
-  ConstantArrayTypes.InsertNode(New, InsertPos);
-  Types.push_back(New);
-  return QualType(New, 0);
+  // PASTA PATCH: Go get the original type. We need to re-calculate the
+  //              `OrigInsertPos` because the buckets in `ConstantArrayTypes`
+  //              may have changed.
+  OrigATP = ConstantArrayTypes.FindNodeOrInsertPos(OrigID, OrigInsertPos);
+  if (OrigSizeExpr && !OrigATP) {
+    void *OrigMem = Allocate(
+        ConstantArrayType::totalSizeToAlloc<const Expr *>(OrigSizeExpr ? 1 : 0),
+        TypeAlignment);
+    OrigATP = new (OrigMem)
+      ConstantArrayType(EltTy, ATP->getCanonicalTypeInternal(),
+                        ArySize, OrigSizeExpr, ASM, IndexTypeQuals);
+    ConstantArrayTypes.InsertNode(OrigATP, OrigInsertPos);
+    Types.push_back(OrigATP);
+  }
+
+  if (ATP && OrigATP)
+    return getAdjustedType(QualType(OrigATP, 0), QualType(ATP, 0));
+
+  return QualType(ATP, 0);
 }
 
 /// getVariableArrayDecayedType - Turns the given type, which may be
@@ -3688,6 +3738,12 @@ QualType ASTContext::getVariableArrayDecayedType(QualType type) const {
                                   cat->getSizeExpr(),
                                   cat->getSizeModifier(),
                                   cat->getIndexTypeCVRQualifiers());
+
+    // PASTA PATCH: If we returned an adjusted type above, then we want to
+    //              desugar it to the internal type.
+    if (auto AT = dyn_cast<AdjustedType>(result.getTypePtr())) {
+      result = AT->getAdjustedType();
+    }
     break;
   }
 
@@ -6867,11 +6923,23 @@ const ArrayType *ASTContext::getAsArrayType(QualType T) const {
   // qualifiers into the array element type and return a new array type.
   QualType NewEltTy = getQualifiedType(ATy->getElementType(), qs);
 
-  if (const auto *CAT = dyn_cast<ConstantArrayType>(ATy))
-    return cast<ArrayType>(getConstantArrayType(NewEltTy, CAT->getSize(),
+  if (const auto *CAT = dyn_cast<ConstantArrayType>(ATy)) {
+
+    // PASTA PATCH: `getConstantArrayType` might return an adjusted type.
+    QualType result = getConstantArrayType(NewEltTy, CAT->getSize(),
                                                 CAT->getSizeExpr(),
                                                 CAT->getSizeModifier(),
-                                           CAT->getIndexTypeCVRQualifiers()));
+                                           CAT->getIndexTypeCVRQualifiers());
+
+    // PASTA PATCH: If we returned an adjusted type above, then we want to
+    //              desugar it to the internal type.
+    if (auto AT = dyn_cast<AdjustedType>(result.getTypePtr())) {
+      result = AT->getAdjustedType();
+    }
+
+    return cast<ArrayType>(result);
+  }
+
   if (const auto *IAT = dyn_cast<IncompleteArrayType>(ATy))
     return cast<ArrayType>(getIncompleteArrayType(NewEltTy,
                                                   IAT->getSizeModifier(),
diff --git a/clang/lib/AST/ExprConstant.cpp b/clang/lib/AST/ExprConstant.cpp
index 9c56ab125..5c573d72a 100644
--- a/clang/lib/AST/ExprConstant.cpp
+++ b/clang/lib/AST/ExprConstant.cpp
@@ -13407,6 +13407,15 @@ bool IntExprEvaluator::VisitUnaryExprOrTypeTraitExpr(
                     Info.Ctx.getOpenMPDefaultSimdAlign(E->getArgumentType()))
             .getQuantity(),
         E);
+
+  // PASTA PATCH: Fake these XNU-specific type traits.
+  case UETT_PtrAuthTypeDiscriminator:
+  case UETT_XNUTypeSummary:
+  case UETT_TMOTypeGetMetadata:
+    return Success(0, E);
+
+  case UETT_XNUTypeSignature:
+    return false;
   }
 
   llvm_unreachable("unknown expr/type trait");
diff --git a/clang/lib/AST/ItaniumMangle.cpp b/clang/lib/AST/ItaniumMangle.cpp
index b23bc5f8d..d8af66dc2 100644
--- a/clang/lib/AST/ItaniumMangle.cpp
+++ b/clang/lib/AST/ItaniumMangle.cpp
@@ -4657,6 +4657,14 @@ recurse:
     };
 
     switch(SAE->getKind()) {
+
+    // PASTA PATCH: Sort of support these.
+    case UETT_PtrAuthTypeDiscriminator:
+    case UETT_XNUTypeSummary:
+    case UETT_TMOTypeGetMetadata:
+    case UETT_XNUTypeSignature:
+      break;
+
     case UETT_SizeOf:
       Out << 's';
       MangleAlignofSizeofArg();
diff --git a/clang/lib/AST/Type.cpp b/clang/lib/AST/Type.cpp
index 54e62a193..324468784 100644
--- a/clang/lib/AST/Type.cpp
+++ b/clang/lib/AST/Type.cpp
@@ -4084,9 +4084,14 @@ bool Type::hasUnnamedOrLocalType() const {
 LinkageInfo LinkageComputer::computeTypeLinkageInfo(const Type *T) {
   switch (T->getTypeClass()) {
 #define TYPE(Class,Base)
-#define NON_CANONICAL_TYPE(Class,Base) case Type::Class:
+
+// PASTA PATCH: For Multiplier Issue #130, we use AdjustedTypes for arrays
+//              and so we go and handle non-canonical types via desugarding
+//              where Clang normally does not.
+#define NON_CANONICAL_TYPE(Class,Base) \
+  case Type::Class: \
+    return computeTypeLinkageInfo(cast<Class ## Type>(T)->desugar());
 #include "clang/AST/TypeNodes.inc"
-    llvm_unreachable("didn't expect a non-canonical type here");
 
 #define TYPE(Class,Base)
 #define DEPENDENT_TYPE(Class,Base) case Type::Class:
diff --git a/clang/lib/Lex/Lexer.cpp b/clang/lib/Lex/Lexer.cpp
index d49d9e9e4..56a8dbe9e 100644
--- a/clang/lib/Lex/Lexer.cpp
+++ b/clang/lib/Lex/Lexer.cpp
@@ -23,6 +23,7 @@
 #include "clang/Lex/LexDiagnostic.h"
 #include "clang/Lex/LiteralSupport.h"
 #include "clang/Lex/MultipleIncludeOpt.h"
+#include "clang/Lex/PPCallbacksEventKind.h"  // PASTA PATCH
 #include "clang/Lex/Preprocessor.h"
 #include "clang/Lex/PreprocessorOptions.h"
 #include "clang/Lex/Token.h"
@@ -2982,6 +2983,14 @@ void Lexer::ReadToEndOfLine(SmallVectorImpl<char> *Result) {
       }
       assert(Tmp.is(tok::eod) && "Unexpected token!");
 
+      // PASTA PATCH: Visibility into all tokens.
+      if (PP) {
+        if (auto Callbacks = PP->getPPCallbacks()) {
+          Callbacks->Event(Tmp, PPCallbacks::TokenFromTokenLexer, 0u);
+          Callbacks->Event(Tmp, PPCallbacks::EndDirective, 0);
+        }
+      }
+
       // Finally, we're done;
       return;
     }
diff --git a/clang/lib/Lex/PPDirectives.cpp b/clang/lib/Lex/PPDirectives.cpp
index 6ae513dea..1db695e18 100644
--- a/clang/lib/Lex/PPDirectives.cpp
+++ b/clang/lib/Lex/PPDirectives.cpp
@@ -27,6 +27,7 @@
 #include "clang/Lex/ModuleLoader.h"
 #include "clang/Lex/ModuleMap.h"
 #include "clang/Lex/PPCallbacks.h"
+#include "clang/Lex/PPCallbacksEventKind.h"  // PASTA PATCH
 #include "clang/Lex/Pragma.h"
 #include "clang/Lex/Preprocessor.h"
 #include "clang/Lex/PreprocessorOptions.h"
@@ -91,6 +92,12 @@ SourceRange Preprocessor::DiscardUntilEndOfDirective() {
     LexUnexpandedToken(Tmp);
   }
   Res.setEnd(Tmp.getLocation());
+
+//  // PASTA PATCH:
+//  if (Callbacks) {
+//    Callbacks->Event(Tmp, PPCallbacks::EndDirective, 0);
+//  }
+
   return Res;
 }
 
@@ -458,7 +465,7 @@ void Preprocessor::SuggestTypoedDirective(const Token &Tok,
 /// If ElseOk is true, then \#else directives are ok, if not, then we have
 /// already seen one so a \#else directive is a duplicate.  When this returns,
 /// the caller can lex the first valid token.
-void Preprocessor::SkipExcludedConditionalBlock(SourceLocation HashTokenLoc,
+void Preprocessor::SkipExcludedConditionalBlock(const Token &HashToken,  // PASTA PATCH
                                                 SourceLocation IfTokenLoc,
                                                 bool FoundNonSkipPortion,
                                                 bool FoundElse,
@@ -484,6 +491,12 @@ void Preprocessor::SkipExcludedConditionalBlock(SourceLocation HashTokenLoc,
     CurPPLexer->pushConditionalLevel(IfTokenLoc, /*isSkipping*/ false,
                                      FoundNonSkipPortion, FoundElse);
 
+  // PASTA PATCH
+  SourceLocation HashTokenLoc = HashToken.getLocation();
+  if (Callbacks) {
+    Callbacks->Event(HashToken, PPCallbacks::BeginSkippedArea, 0);
+  }
+
   // Enter raw mode to disable identifier lookup (and thus macro expansion),
   // disabling warnings, etc.
   CurPPLexer->LexingRawMode = true;
@@ -631,6 +644,12 @@ void Preprocessor::SkipExcludedConditionalBlock(SourceLocation HashTokenLoc,
       if (Sub.empty() ||   // "if"
           Sub == "def" ||   // "ifdef"
           Sub == "ndef") {  // "ifndef"
+
+        // PASTA PATCH:
+        if (Callbacks) {
+          Callbacks->Event(Tok, PPCallbacks::BeginSkippedArea, 0);
+        }
+
         // We know the entire #if/#ifdef/#ifndef block will be skipped, don't
         // bother parsing the condition.
         DiscardUntilEndOfDirective();
@@ -641,6 +660,12 @@ void Preprocessor::SkipExcludedConditionalBlock(SourceLocation HashTokenLoc,
         SuggestTypoedDirective(Tok, Directive);
       }
     } else if (Directive[0] == 'e') {
+
+      // PASTA PATCH:
+      if (Callbacks) {
+        Callbacks->Event(Tok, PPCallbacks::BeginSkippedArea, 0);
+      }
+
       StringRef Sub = Directive.substr(1);
       if (Sub == "ndif") {  // "endif"
         PPConditionalInfo CondInfo;
@@ -1089,16 +1114,16 @@ private:
 /// #define (to warn about macros that don't match the PCH)
 /// #pragma (to check for pragma hdrstop).
 /// All other directives are completely discarded.
-void Preprocessor::HandleSkippedDirectiveWhileUsingPCH(Token &Result,
-                                                       SourceLocation HashLoc) {
+void Preprocessor::HandleSkippedDirectiveWhileUsingPCH(  // PASTA PATCH
+    Token &Result, const Token &SavedHash) {  // PASTA PATCH
   if (const IdentifierInfo *II = Result.getIdentifierInfo()) {
     if (II->getPPKeywordID() == tok::pp_define) {
-      return HandleDefineDirective(Result,
-                                   /*ImmediatelyAfterHeaderGuard=*/false);
+      return HandleDefineDirective(SavedHash, Result,  // PASTA PATCH
+                                   /*ImmediatelyAfterHeaderGuard=*/false);  // PASTA PATCH
     }
     if (SkippingUntilPCHThroughHeader &&
         II->getPPKeywordID() == tok::pp_include) {
-      return HandleIncludeDirective(HashLoc, Result);
+      return HandleIncludeDirective(SavedHash, Result);  // PASTA PATCH
     }
     if (SkippingUntilPragmaHdrStop && II->getPPKeywordID() == tok::pp_pragma) {
       Lex(Result);
@@ -1137,10 +1162,36 @@ void Preprocessor::HandleDirective(Token &Result) {
   // Save the '#' token in case we need to return it later.
   Token SavedHash = Result;
 
+  // PASTA PATCH: Tell us when we're about to start a directive.
+  if (Callbacks) {
+    Callbacks->Event(SavedHash, PPCallbacks::BeginDirective, 0);
+  }
+
   // Read the next token, the directive flavor.  This isn't expanded due to
   // C99 6.10.3p8.
   LexUnexpandedToken(Result);
 
+  // PASTA PATCH: Tell us when we're about to start a directive.
+  if (Callbacks) {
+    switch (Result.getKind()) {
+      case tok::identifier:
+      case tok::raw_identifier:
+      case tok::kw_if:
+      case tok::kw_else:
+        Callbacks->Event(SavedHash, PPCallbacks::SetNamedDirective,
+                         reinterpret_cast<uintptr_t>(&Result));
+        break;
+      case tok::eod:
+      case tok::code_completion:
+      case tok::numeric_constant:
+      case tok::string_literal:
+      default:
+        Callbacks->Event(SavedHash, PPCallbacks::SetUnnamedDirective,
+                         reinterpret_cast<uintptr_t>(&Result));
+        break;
+    }
+  }
+
   // C99 6.10.3p11: Is this preprocessor directive in macro invocation?  e.g.:
   //   #define A(x) #x
   //   A(abc
@@ -1174,7 +1225,7 @@ void Preprocessor::HandleDirective(Token &Result) {
   ResetMacroExpansionHelper helper(this);
 
   if (SkippingUntilPCHThroughHeader || SkippingUntilPragmaHdrStop)
-    return HandleSkippedDirectiveWhileUsingPCH(Result, SavedHash.getLocation());
+    return HandleSkippedDirectiveWhileUsingPCH(Result, SavedHash);  // PASTA PATCH
 
   switch (Result.getKind()) {
   case tok::eod:
@@ -1188,7 +1239,7 @@ void Preprocessor::HandleDirective(Token &Result) {
   case tok::numeric_constant:  // # 7  GNU line marker directive.
     if (getLangOpts().AsmPreprocessor)
       break;  // # 4 is not a preprocessor directive in .S files.
-    return HandleDigitDirective(Result);
+    return HandleDigitDirective(SavedHash, Result);  // PASTA PATCH
   default:
     IdentifierInfo *II = Result.getIdentifierInfo();
     if (!II) break; // Not an identifier.
@@ -1218,24 +1269,25 @@ void Preprocessor::HandleDirective(Token &Result) {
     // C99 6.10.2 - Source File Inclusion.
     case tok::pp_include:
       // Handle #include.
-      return HandleIncludeDirective(SavedHash.getLocation(), Result);
+      return HandleIncludeDirective(SavedHash, Result);  // PASTA PATCH
     case tok::pp___include_macros:
       // Handle -imacros.
-      return HandleIncludeMacrosDirective(SavedHash.getLocation(), Result);
+      return HandleIncludeMacrosDirective(SavedHash, Result);  // PASTA PATCH
 
     // C99 6.10.3 - Macro Replacement.
     case tok::pp_define:
-      return HandleDefineDirective(Result, ImmediatelyAfterTopLevelIfndef);
+      return HandleDefineDirective(SavedHash, Result,  // PASTA PATCH
+                                   ImmediatelyAfterTopLevelIfndef);  // PASTA PATCH
     case tok::pp_undef:
-      return HandleUndefDirective();
+      return HandleUndefDirective(SavedHash);  // PASTA PATCH
 
     // C99 6.10.4 - Line Control.
     case tok::pp_line:
-      return HandleLineDirective();
+      return HandleLineDirective(SavedHash);  // PASTA PATCH
 
     // C99 6.10.5 - Error Directive.
     case tok::pp_error:
-      return HandleUserDiagnosticDirective(Result, false);
+      return HandleUserDiagnosticDirective(SavedHash, Result, false);  // PASTA PATCH
 
     // C99 6.10.6 - Pragma Directive.
     case tok::pp_pragma:
@@ -1243,9 +1295,9 @@ void Preprocessor::HandleDirective(Token &Result) {
 
     // GNU Extensions.
     case tok::pp_import:
-      return HandleImportDirective(SavedHash.getLocation(), Result);
+      return HandleImportDirective(SavedHash, Result);  // PASTA PATCH
     case tok::pp_include_next:
-      return HandleIncludeNextDirective(SavedHash.getLocation(), Result);
+      return HandleIncludeNextDirective(SavedHash, Result);  // PASTA PATCH
 
     case tok::pp_warning:
       if (LangOpts.CPlusPlus)
@@ -1258,11 +1310,11 @@ void Preprocessor::HandleDirective(Token &Result) {
                                   : diag::ext_pp_warning_directive)
             << /*C2x*/ 0;
 
-      return HandleUserDiagnosticDirective(Result, true);
+      return HandleUserDiagnosticDirective(SavedHash, Result, true);  // PASTA PATCH
     case tok::pp_ident:
-      return HandleIdentSCCSDirective(Result);
+      return HandleIdentSCCSDirective(SavedHash, Result);  // PASTA PATCH
     case tok::pp_sccs:
-      return HandleIdentSCCSDirective(Result);
+      return HandleIdentSCCSDirective(SavedHash, Result);  // PASTA PATCH
     case tok::pp_assert:
       //isExtension = true;  // FIXME: implement #assert
       break;
@@ -1272,12 +1324,12 @@ void Preprocessor::HandleDirective(Token &Result) {
 
     case tok::pp___public_macro:
       if (getLangOpts().Modules || getLangOpts().ModulesLocalVisibility)
-        return HandleMacroPublicDirective(Result);
+        return HandleMacroPublicDirective(SavedHash, Result);  // PASTA PATCH
       break;
 
     case tok::pp___private_macro:
       if (getLangOpts().Modules || getLangOpts().ModulesLocalVisibility)
-        return HandleMacroPrivateDirective();
+        return HandleMacroPrivateDirective(SavedHash);  // PASTA PATCH
       break;
     }
     break;
@@ -1288,6 +1340,11 @@ void Preprocessor::HandleDirective(Token &Result) {
   // various pseudo-ops.  Just return the # token and push back the following
   // token to be lexed next time.
   if (getLangOpts().AsmPreprocessor) {
+    // PASTA PATCH: Get visibility on end of macro directives.
+    if (Callbacks) {
+      Callbacks->Event(SavedHash, PPCallbacks::EndNonDirective, 0);
+    }
+
     auto Toks = std::make_unique<Token[]>(2);
     // Return the # and the token after it.
     Toks[0] = SavedHash;
@@ -1376,7 +1433,7 @@ static bool GetLineValue(Token &DigitTok, unsigned &Val,
 ///   # line digit-sequence
 ///   # line digit-sequence "s-char-sequence"
 /// \endverbatim
-void Preprocessor::HandleLineDirective() {
+void Preprocessor::HandleLineDirective(const Token &SavedHash) {  // PASTA PATCH
   // Read the line # and string argument.  Per C99 6.10.4p5, these tokens are
   // expanded.
   Token DigitTok;
@@ -1538,7 +1595,8 @@ static bool ReadLineMarkerFlags(bool &IsFileEntry, bool &IsFileExit,
 ///     # 42 "file" ('1' | '2')?
 ///     # 42 "file" ('1' | '2')? '3' '4'?
 ///
-void Preprocessor::HandleDigitDirective(Token &DigitTok) {
+void Preprocessor::HandleDigitDirective(  // PASTA PATCH
+    const Token &SavedHash, Token &DigitTok) {  // PASTA PATCH
   // Validate the number and convert it to an unsigned.  GNU does not have a
   // line # limit other than it fit in 32-bits.
   unsigned LineNo;
@@ -1614,8 +1672,8 @@ void Preprocessor::HandleDigitDirective(Token &DigitTok) {
 
 /// HandleUserDiagnosticDirective - Handle a #warning or #error directive.
 ///
-void Preprocessor::HandleUserDiagnosticDirective(Token &Tok,
-                                                 bool isWarning) {
+void Preprocessor::HandleUserDiagnosticDirective(const Token &SavedHash,  // PASTA PATCH
+                                                 Token &Tok, bool isWarning) {  // PASTA PATCH
   // Read the rest of the line raw.  We do this because we don't want macros
   // to be expanded and we don't require that the tokens be valid preprocessing
   // tokens.  For example, this is allowed: "#warning `   'foo".  GCC does
@@ -1636,7 +1694,8 @@ void Preprocessor::HandleUserDiagnosticDirective(Token &Tok,
 
 /// HandleIdentSCCSDirective - Handle a #ident/#sccs directive.
 ///
-void Preprocessor::HandleIdentSCCSDirective(Token &Tok) {
+void Preprocessor::HandleIdentSCCSDirective(const Token &SavedHash,  // PASTA PATCH
+                                            Token &Tok) {  // PASTA PATCH
   // Yes, this directive is an extension.
   Diag(Tok, diag::ext_pp_ident_directive);
 
@@ -1671,7 +1730,8 @@ void Preprocessor::HandleIdentSCCSDirective(Token &Tok) {
 }
 
 /// Handle a #public directive.
-void Preprocessor::HandleMacroPublicDirective(Token &Tok) {
+void Preprocessor::HandleMacroPublicDirective(const Token &SavedHash,  // PASTA PATCH
+                                              Token &Tok) {  // PASTA PATCH
   Token MacroNameTok;
   ReadMacroName(MacroNameTok, MU_Undef);
 
@@ -1698,7 +1758,7 @@ void Preprocessor::HandleMacroPublicDirective(Token &Tok) {
 }
 
 /// Handle a #private directive.
-void Preprocessor::HandleMacroPrivateDirective() {
+void Preprocessor::HandleMacroPrivateDirective(const Token &SavedHash) {  // PASTA PATCH
   Token MacroNameTok;
   ReadMacroName(MacroNameTok, MU_Undef);
 
@@ -1935,10 +1995,11 @@ Preprocessor::getIncludeNextStart(const Token &IncludeNextTok) const {
 /// routine with functionality shared between \#include, \#include_next and
 /// \#import.  LookupFrom is set when this is a \#include_next directive, it
 /// specifies the file to start searching from.
-void Preprocessor::HandleIncludeDirective(SourceLocation HashLoc,
+void Preprocessor::HandleIncludeDirective(const Token &SavedHash,  // PASTA PATCH
                                           Token &IncludeTok,
                                           ConstSearchDirIterator LookupFrom,
                                           const FileEntry *LookupFromFile) {
+  SourceLocation HashLoc = SavedHash.getLocation();  // PASTA PATCH
   Token FilenameTok;
   if (LexHeaderName(FilenameTok))
     return;
@@ -2563,7 +2624,7 @@ Preprocessor::ImportAction Preprocessor::HandleHeaderIncludeOrImport(
 
 /// HandleIncludeNextDirective - Implements \#include_next.
 ///
-void Preprocessor::HandleIncludeNextDirective(SourceLocation HashLoc,
+void Preprocessor::HandleIncludeNextDirective(const Token &SavedHash,  // PASTA PATCH
                                               Token &IncludeNextTok) {
   Diag(IncludeNextTok, diag::ext_pp_include_next_directive);
 
@@ -2571,7 +2632,7 @@ void Preprocessor::HandleIncludeNextDirective(SourceLocation HashLoc,
   const FileEntry *LookupFromFile;
   std::tie(Lookup, LookupFromFile) = getIncludeNextStart(IncludeNextTok);
 
-  return HandleIncludeDirective(HashLoc, IncludeNextTok, Lookup,
+  return HandleIncludeDirective(SavedHash, IncludeNextTok, Lookup,
                                 LookupFromFile);
 }
 
@@ -2591,21 +2652,21 @@ void Preprocessor::HandleMicrosoftImportDirective(Token &Tok) {
 
 /// HandleImportDirective - Implements \#import.
 ///
-void Preprocessor::HandleImportDirective(SourceLocation HashLoc,
-                                         Token &ImportTok) {
+void Preprocessor::HandleImportDirective(const Token &SavedHash,  // PASTA PATCH
+                                         Token &ImportTok) {  // PASTA PATCH
   if (!LangOpts.ObjC) {  // #import is standard for ObjC.
     if (LangOpts.MSVCCompat)
       return HandleMicrosoftImportDirective(ImportTok);
     Diag(ImportTok, diag::ext_pp_import_directive);
   }
-  return HandleIncludeDirective(HashLoc, ImportTok);
+  return HandleIncludeDirective(SavedHash, ImportTok);  // PASTA PATCH
 }
 
 /// HandleIncludeMacrosDirective - The -imacros command line option turns into a
 /// pseudo directive in the predefines buffer.  This handles it by sucking all
 /// tokens through the preprocessor and discarding them (only keeping the side
 /// effects on the preprocessor).
-void Preprocessor::HandleIncludeMacrosDirective(SourceLocation HashLoc,
+void Preprocessor::HandleIncludeMacrosDirective(const Token &SavedHash,  // PASTA PATCH
                                                 Token &IncludeMacrosTok) {
   // This directive should only occur in the predefines buffer.  If not, emit an
   // error and reject it.
@@ -2619,7 +2680,7 @@ void Preprocessor::HandleIncludeMacrosDirective(SourceLocation HashLoc,
 
   // Treat this as a normal #include for checking purposes.  If this is
   // successful, it will push a new lexer onto the include stack.
-  HandleIncludeDirective(HashLoc, IncludeMacrosTok);
+  HandleIncludeDirective(SavedHash, IncludeMacrosTok);  // PASTA PATCH
 
   Token TmpTok;
   do {
@@ -3008,7 +3069,8 @@ MacroInfo *Preprocessor::ReadOptionalMacroParameterListAndBody(
 /// HandleDefineDirective - Implements \#define.  This consumes the entire macro
 /// line then lets the caller lex the next real token.
 void Preprocessor::HandleDefineDirective(
-    Token &DefineTok, const bool ImmediatelyAfterHeaderGuard) {
+    const Token &SavedHash, Token &DefineTok,  // PASTA PATCH
+    const bool ImmediatelyAfterHeaderGuard) {  // PASTA PATCH
   ++NumDefined;
 
   Token MacroNameTok;
@@ -3162,7 +3224,7 @@ void Preprocessor::HandleDefineDirective(
 
 /// HandleUndefDirective - Implements \#undef.
 ///
-void Preprocessor::HandleUndefDirective() {
+void Preprocessor::HandleUndefDirective(const Token &SavedHash) {  // PASTA PATCH
   ++NumUndefined;
 
   Token MacroNameTok;
@@ -3226,7 +3288,7 @@ void Preprocessor::HandleIfdefDirective(Token &Result,
   if (MacroNameTok.is(tok::eod)) {
     // Skip code until we get to #endif.  This helps with recovery by not
     // emitting an error when the #endif is reached.
-    SkipExcludedConditionalBlock(HashToken.getLocation(),
+    SkipExcludedConditionalBlock(HashToken,  // PASTA PATCH
                                  DirectiveTok.getLocation(),
                                  /*Foundnonskip*/ false, /*FoundElse*/ false);
     return;
@@ -3281,7 +3343,7 @@ void Preprocessor::HandleIfdefDirective(Token &Result,
                                      /*foundelse*/false);
   } else {
     // No, skip the contents of this block.
-    SkipExcludedConditionalBlock(HashToken.getLocation(),
+    SkipExcludedConditionalBlock(HashToken,  // PASTA PATCH
                                  DirectiveTok.getLocation(),
                                  /*Foundnonskip*/ false,
                                  /*FoundElse*/ false);
@@ -3334,7 +3396,7 @@ void Preprocessor::HandleIfDirective(Token &IfToken,
                                    /*foundnonskip*/true, /*foundelse*/false);
   } else {
     // No, skip the contents of this block.
-    SkipExcludedConditionalBlock(HashToken.getLocation(), IfToken.getLocation(),
+    SkipExcludedConditionalBlock(HashToken, IfToken.getLocation(),  // PASTA PATCH
                                  /*Foundnonskip*/ false,
                                  /*FoundElse*/ false);
   }
@@ -3402,7 +3464,7 @@ void Preprocessor::HandleElseDirective(Token &Result, const Token &HashToken) {
   }
 
   // Finally, skip the rest of the contents of this block.
-  SkipExcludedConditionalBlock(HashToken.getLocation(), CI.IfLoc,
+  SkipExcludedConditionalBlock(HashToken, CI.IfLoc,  // PASTA PATCH
                                /*Foundnonskip*/ true,
                                /*FoundElse*/ true, Result.getLocation());
 }
@@ -3483,6 +3545,6 @@ void Preprocessor::HandleElifFamilyDirective(Token &ElifToken,
 
   // Finally, skip the rest of the contents of this block.
   SkipExcludedConditionalBlock(
-      HashToken.getLocation(), CI.IfLoc, /*Foundnonskip*/ true,
+      HashToken, CI.IfLoc, /*Foundnonskip*/ true,  // PASTA PATCH
       /*FoundElse*/ CI.FoundElse, ElifToken.getLocation());
 }
diff --git a/clang/lib/Lex/PPExpressions.cpp b/clang/lib/Lex/PPExpressions.cpp
index aa411cfc5..d268bc3c7 100644
--- a/clang/lib/Lex/PPExpressions.cpp
+++ b/clang/lib/Lex/PPExpressions.cpp
@@ -25,6 +25,7 @@
 #include "clang/Lex/LiteralSupport.h"
 #include "clang/Lex/MacroInfo.h"
 #include "clang/Lex/PPCallbacks.h"
+#include "clang/Lex/PPCallbacksEventKind.h"  // PASTA PATCH
 #include "clang/Lex/Preprocessor.h"
 #include "clang/Lex/Token.h"
 #include "llvm/ADT/APSInt.h"
@@ -101,6 +102,32 @@ struct DefinedTracker {
 /// EvaluateDefined - Process a 'defined(sym)' expression.
 static bool EvaluateDefined(PPValue &Result, Token &PeekTok, DefinedTracker &DT,
                             bool ValueLive, Preprocessor &PP) {
+  // PASTA PATCH
+  PPCallbacks *Callbacks = PP.getPPCallbacks();
+  Token SavedStart = PeekTok;
+  if (Callbacks) {
+    Callbacks->Event(SavedStart, PPCallbacks::BeginDelayedSubstitution, 0);
+  }
+  auto Expand = [&] (void) {
+    if (Callbacks) {
+      Token ResultTok;
+      ResultTok.startToken();
+      ResultTok.setKind(tok::numeric_constant);
+      const char *ResultStr = Result.Val.getExtValue() ? "1" : "0";
+      PP.CreateString(ResultStr, ResultTok, SavedStart.getLocation(),
+                      PeekTok.getEndLoc());
+
+      Callbacks->Event(PeekTok, PPCallbacks::SwitchToSubstitution,
+                       reinterpret_cast<uintptr_t>(&SavedStart));
+
+      Callbacks->Event(ResultTok, PPCallbacks::TokenFromTokenLexer,
+                       SavedStart.getLocation().getRawEncoding());
+
+      Callbacks->Event(SavedStart, PPCallbacks::EndSubstitution,
+                       reinterpret_cast<uintptr_t>(&SavedStart));
+    }
+  };
+
   SourceLocation beginLoc(PeekTok.getLocation());
   Result.setBegin(beginLoc);
 
@@ -154,12 +181,14 @@ static bool EvaluateDefined(PPValue &Result, Token &PeekTok, DefinedTracker &DT,
       PP.Diag(LParenLoc, diag::note_matching) << tok::l_paren;
       return true;
     }
+    Expand();  // PASTA PATCH
     // Consume the ).
     PP.LexNonComment(PeekTok);
     Result.setEnd(PeekTok.getLocation());
   } else {
     // Consume identifier.
     Result.setEnd(PeekTok.getLocation());
+    Expand();  // PASTA PATCH
     PP.LexNonComment(PeekTok);
   }
 
diff --git a/clang/lib/Lex/PPLexerChange.cpp b/clang/lib/Lex/PPLexerChange.cpp
index 66168467e..95228691b 100644
--- a/clang/lib/Lex/PPLexerChange.cpp
+++ b/clang/lib/Lex/PPLexerChange.cpp
@@ -16,6 +16,7 @@
 #include "clang/Lex/HeaderSearch.h"
 #include "clang/Lex/LexDiagnostic.h"
 #include "clang/Lex/MacroInfo.h"
+#include "clang/Lex/PPCallbacksEventKind.h"  // PASTA PATCH
 #include "clang/Lex/Preprocessor.h"
 #include "clang/Lex/PreprocessorOptions.h"
 #include "llvm/ADT/StringSwitch.h"
@@ -30,6 +31,36 @@ using namespace clang;
 // Miscellaneous Methods.
 //===----------------------------------------------------------------------===//
 
+void Preprocessor::PopIncludeMacroStack() {
+
+  // PASTA PATCH: Tell us about the end of macro expansions.
+  if (Callbacks && CurTokenLexer && CurTokenLexer->Macro) {
+    Callbacks->Event(CurTokenLexer->MacroNameTok,
+                     PPCallbacks::EndMacroExpansion,
+                     reinterpret_cast<uintptr_t>(CurTokenLexer->Macro));
+  }
+
+  // PASTA PATCH: Make us aware of the end of `_Pragma` handling.
+  if (Callbacks && CurPPLexer && CurLexer.get() == CurPPLexer &&
+      CurLexer->isPragmaLexer()) {
+    Token PragmaTok;
+    PragmaTok.setKind(tok::raw_identifier);
+    PragmaTok.setLocation(SourceMgr.getExpansionLoc(CurLexer->getFileLoc()));
+    PragmaTok.setLength(7u);
+    PragmaTok.setRawIdentifierData(
+        SourceMgr.getCharacterData(PragmaTok.getLocation(), nullptr));
+    Callbacks->Event(PragmaTok, PPCallbacks::EndMacroExpansion, 0);
+  }
+
+  CurLexer = std::move(IncludeMacroStack.back().TheLexer);
+  CurPPLexer = IncludeMacroStack.back().ThePPLexer;
+  CurTokenLexer = std::move(IncludeMacroStack.back().TheTokenLexer);
+  CurDirLookup  = IncludeMacroStack.back().TheDirLookup;
+  CurLexerSubmodule = IncludeMacroStack.back().TheSubmodule;
+  CurLexerKind = IncludeMacroStack.back().CurLexerKind;
+  IncludeMacroStack.pop_back();
+}
+
 /// isInPrimaryFile - Return true if we're in the top-level file, not in a
 /// \#include.  This looks through macro expansions and active _Pragma lexers.
 bool Preprocessor::isInPrimaryFile() const {
@@ -588,6 +619,14 @@ bool Preprocessor::HandleEndOfTokenLexer(Token &Result) {
   assert(CurTokenLexer && !CurPPLexer &&
          "Ending a macro when currently in a #include file!");
 
+  // PASTA PATCH: Tell us about the end of macro expansions.
+  if (CurTokenLexer && CurTokenLexer->Macro) {
+    Callbacks->Event(CurTokenLexer->MacroNameTok,
+                     PPCallbacks::EndMacroExpansion,
+                     reinterpret_cast<uintptr_t>(CurTokenLexer->Macro));
+    CurTokenLexer->Macro = nullptr;
+  }
+
   if (!MacroExpandingLexersStack.empty() &&
       MacroExpandingLexersStack.back().first == CurTokenLexer.get())
     removeCachedMacroExpandedTokensOfLastLexer();
diff --git a/clang/lib/Lex/PPMacroExpansion.cpp b/clang/lib/Lex/PPMacroExpansion.cpp
index 76d0d53ed..b278cbbed 100644
--- a/clang/lib/Lex/PPMacroExpansion.cpp
+++ b/clang/lib/Lex/PPMacroExpansion.cpp
@@ -29,6 +29,7 @@
 #include "clang/Lex/LiteralSupport.h"
 #include "clang/Lex/MacroArgs.h"
 #include "clang/Lex/MacroInfo.h"
+#include "clang/Lex/PPCallbacksEventKind.h"  // PASTA PATCH
 #include "clang/Lex/Preprocessor.h"
 #include "clang/Lex/PreprocessorLexer.h"
 #include "clang/Lex/PreprocessorOptions.h"
@@ -59,6 +60,58 @@
 
 using namespace clang;
 
+namespace {
+
+// PASTA PATCH: Tell us about the end of macro expansions. We have to add
+// this as a post-lex action, so that we can observe what is actually lexed
+// into `Identifier`.
+struct DeferExpansionEnd {
+  std::function<void(const Token &)> &PostLexAction;
+  PPCallbacks * const Callbacks;
+  Token Identifier;
+  MacroInfo * const MI;
+
+  DeferExpansionEnd(std::function<void(const Token &)> &PostLexAction_,
+                    PPCallbacks *Callbacks_, Token Identifier_, MacroInfo *MI_)
+      : PostLexAction(PostLexAction_),
+        Callbacks(Callbacks_),
+        Identifier(std::move(Identifier_)),
+        MI(MI_) {}
+
+  ~DeferExpansionEnd(void) {
+    if (Callbacks) {
+      PostLexAction = [CB = Callbacks, Ident = std::move(Identifier), Info = MI,
+                       PrevPostLexAction = std::move(PostLexAction)]
+                      (const Token &Tok) {
+        CB->Event(Ident, PPCallbacks::EndMacroExpansion,
+                  reinterpret_cast<uintptr_t>(Info));
+        PrevPostLexAction(Tok);
+      };
+    }
+  }
+};
+
+struct DeferExpansionCancellation {
+  std::function<void(void)> Action;
+  bool DoCancel{true};
+
+  template <typename CB>
+  DeferExpansionCancellation(CB Action_)
+      : Action(std::move(Action_)) {}
+
+  ~DeferExpansionCancellation(void) {
+    if (DoCancel) {
+      Action();
+    }
+  }
+
+  void DisableCancellation(void) {
+    DoCancel = false;
+  }
+};
+
+}  // namespace
+
 MacroDirective *
 Preprocessor::getLocalMacroDirectiveHistory(const IdentifierInfo *II) const {
   if (!II->hadMacroDefinition())
@@ -480,6 +533,19 @@ bool Preprocessor::HandleMacroExpandedIdentifier(Token &Identifier,
 
   MacroInfo *MI = M.getMacroInfo();
 
+  // PASTA PATCH: Visibility into macro expansion.
+  Token SavedIdentifier = Identifier;
+  if (Callbacks) {
+    Callbacks->Event(SavedIdentifier, PPCallbacks::BeginMacroExpansion,
+                     reinterpret_cast<uintptr_t>(MI));
+  }
+  DeferExpansionCancellation CancelExpansion([&, this] (void) {
+    if (Callbacks) {
+      Callbacks->Event(SavedIdentifier, PPCallbacks::CancelExpansion,
+                       reinterpret_cast<uintptr_t>(MI));
+    }
+  });
+
   // If this is a macro expansion in the "#if !defined(x)" line for the file,
   // then the macro could expand to different things in other contexts, we need
   // to disable the optimization in this case.
@@ -490,6 +556,8 @@ bool Preprocessor::HandleMacroExpandedIdentifier(Token &Identifier,
     if (Callbacks)
       Callbacks->MacroExpands(Identifier, M, Identifier.getLocation(),
                               /*Args=*/nullptr);
+
+    CancelExpansion.DisableCancellation();  // PASTA PATCH
     ExpandBuiltinMacro(Identifier);
     return true;
   }
@@ -511,7 +579,22 @@ bool Preprocessor::HandleMacroExpandedIdentifier(Token &Identifier,
     InMacroArgs = true;
     ArgMacro = &Identifier;
 
-    Args = ReadMacroCallArgumentList(Identifier, MI, ExpansionEnd);
+    // PASTA PATCH: Visibility into macro expansion.
+    if (Callbacks) {
+      Callbacks->Event(SavedIdentifier, PPCallbacks::BeginMacroCallArgumentList,
+                       reinterpret_cast<uintptr_t>(MI));
+    }
+
+    // PASTA PATCH: Visibility to last token in argument list.
+    Token ExpansionEndTok;
+    Args = ReadMacroCallArgumentList(Identifier, MI, ExpansionEndTok);
+    ExpansionEnd = ExpansionEndTok.getLocation();
+
+    // PASTA PATCH: Visibility into macro expansion.
+    if (Callbacks) {
+      Callbacks->Event(ExpansionEndTok, PPCallbacks::EndMacroCallArgumentList,
+                       reinterpret_cast<uintptr_t>(Args));
+    }
 
     // Finished parsing args.
     InMacroArgs = false;
@@ -570,7 +653,7 @@ bool Preprocessor::HandleMacroExpandedIdentifier(Token &Identifier,
 
   // If this macro expands to no tokens, don't bother to push it onto the
   // expansion stack, only to take it right back off.
-  if (MI->getNumTokens() == 0) {
+  if (false && MI->getNumTokens() == 0) {  // PASTA PATCH
     // No need for arg info.
     if (Args) Args->destroy(*this);
 
@@ -580,7 +663,7 @@ bool Preprocessor::HandleMacroExpandedIdentifier(Token &Identifier,
     PropagateLineStartLeadingSpaceInfo(Identifier);
     ++NumFastMacroExpanded;
     return false;
-  } else if (MI->getNumTokens() == 1 &&
+  } else if (false && MI->getNumTokens() == 1 &&  // PASTA PATCH
              isTrivialSingleTokenExpansion(MI, Identifier.getIdentifierInfo(),
                                            *this)) {
     // Otherwise, if this macro expands into a single trivially-expanded
@@ -628,6 +711,13 @@ bool Preprocessor::HandleMacroExpandedIdentifier(Token &Identifier,
     return true;
   }
 
+  // PASTA PATCH: Switch state to now start expanding.
+  CancelExpansion.DisableCancellation();
+  if (Callbacks) {
+    Callbacks->Event(SavedIdentifier, PPCallbacks::SwitchToExpansion,
+                     reinterpret_cast<uintptr_t>(MI));
+  }
+
   // Start expanding the macro.
   EnterMacro(Identifier, ExpansionEnd, MI, Args);
   return false;
@@ -767,13 +857,13 @@ static bool GenerateNewArgTokens(Preprocessor &PP,
 /// error.
 MacroArgs *Preprocessor::ReadMacroCallArgumentList(Token &MacroName,
                                                    MacroInfo *MI,
-                                                   SourceLocation &MacroEnd) {
+                                                   Token &Tok) {  // PASTA PATCH
   // The number of fixed arguments to parse.
   unsigned NumFixedArgsLeft = MI->getNumParams();
   bool isVariadic = MI->isVariadic();
 
   // Outer loop, while there are more arguments, keep reading them.
-  Token Tok;
+  // Token Tok;  // PASTA PATCH: Taken from argument.
 
   // Read arguments as unexpanded tokens.  This avoids issues, e.g., where
   // an argument value in a macro could expand to ',' or '(' or ')'.
@@ -786,6 +876,9 @@ MacroArgs *Preprocessor::ReadMacroCallArgumentList(Token &MacroName,
   SmallVector<Token, 64> ArgTokens;
   bool ContainsCodeCompletionTok = false;
   bool FoundElidedComma = false;
+  bool InVariadicSection = false;  // PASTA PATCH
+  bool InArgument = false;  // PASTA PATCH
+  Token ArgStartTok;  // PASTA PATCH
 
   SourceLocation TooManyArgsLoc;
 
@@ -800,6 +893,21 @@ MacroArgs *Preprocessor::ReadMacroCallArgumentList(Token &MacroName,
     size_t ArgTokenStart = ArgTokens.size();
     SourceLocation ArgStartLoc = Tok.getLocation();
 
+    // PASTA PATCH: Visibility into macro expansion.
+    ArgStartTok = Tok;
+    if (Callbacks) {
+      if (isVariadic && !NumFixedArgsLeft) {
+        Callbacks->Event(ArgStartTok, PPCallbacks::BeginVariadicCallArgumentList,
+                         reinterpret_cast<uintptr_t>(&MacroName));
+        InVariadicSection = true;
+      }
+      if (NumFixedArgsLeft) {
+        Callbacks->Event(ArgStartTok, PPCallbacks::BeginMacroCallArgument,
+                         reinterpret_cast<uintptr_t>(&MacroName));
+        InArgument = true;
+      }
+    }
+
     // C99 6.10.3p11: Keep track of the number of l_parens we have seen.  Note
     // that we already consumed the first one.
     unsigned NumParens = 0;
@@ -826,7 +934,7 @@ MacroArgs *Preprocessor::ReadMacroCallArgumentList(Token &MacroName,
       } else if (Tok.is(tok::r_paren)) {
         // If we found the ) token, the macro arg list is done.
         if (NumParens-- == 0) {
-          MacroEnd = Tok.getLocation();
+          // MacroEnd = Tok.getLocation();  // PASTA PATCH
           if (!ArgTokens.empty() &&
               ArgTokens.back().commaAfterElided()) {
             FoundElidedComma = true;
@@ -854,6 +962,27 @@ MacroArgs *Preprocessor::ReadMacroCallArgumentList(Token &MacroName,
             break;
           if (NumFixedArgsLeft > 1)
             break;
+
+          // PASTA PATCH: Visibility into variadic macro expansion.
+          if (Callbacks) {
+            if (InArgument) {
+              Callbacks->Event(ArgStartTok, PPCallbacks::EndMacroCallArgument,
+                               reinterpret_cast<uintptr_t>(&Tok));
+              InArgument = false;
+            }
+            ArgStartTok = Tok;
+
+            if (!InVariadicSection) {
+              Callbacks->Event(
+                  ArgStartTok, PPCallbacks::BeginVariadicCallArgumentList,
+                  reinterpret_cast<uintptr_t>(&MacroName));
+              InVariadicSection = true;
+            }
+
+            Callbacks->Event(ArgStartTok, PPCallbacks::BeginMacroCallArgument,
+                             reinterpret_cast<uintptr_t>(&MacroName));
+            InArgument = true;
+          }
         }
       } else if (Tok.is(tok::comment) && !KeepMacroComments) {
         // If this is a comment token in the argument list and we're just in
@@ -903,6 +1032,15 @@ MacroArgs *Preprocessor::ReadMacroCallArgumentList(Token &MacroName,
                     ? diag::warn_cxx98_compat_empty_fnmacro_arg
                     : diag::ext_empty_fnmacro_arg);
 
+    // PASTA PATCH:
+    if (Callbacks) {
+      if (InArgument) {
+        InArgument = false;
+        Callbacks->Event(ArgStartTok, PPCallbacks::EndMacroCallArgument,
+                         reinterpret_cast<uintptr_t>(&Tok));
+      }
+    }
+
     // Add a marker EOF token to the end of the token list for this argument.
     Token EOFTok;
     EOFTok.startToken();
@@ -915,6 +1053,18 @@ MacroArgs *Preprocessor::ReadMacroCallArgumentList(Token &MacroName,
       --NumFixedArgsLeft;
   }
 
+  if (Callbacks) {
+    if (InArgument) {
+      InArgument = false;
+      Callbacks->Event(ArgStartTok, PPCallbacks::EndMacroCallArgument,
+                       reinterpret_cast<uintptr_t>(&Tok));
+    }
+    if (InVariadicSection) {
+      Callbacks->Event(ArgStartTok, PPCallbacks::EndVariadicCallArgumentList,
+                       reinterpret_cast<uintptr_t>(&Tok));
+    }
+  }
+
   // Okay, we either found the r_paren.  Check to see if we parsed too few
   // arguments.
   unsigned MinArgsExpected = MI->getNumParams();
@@ -1182,6 +1332,17 @@ static bool EvaluateHasIncludeCommon(Token &Tok, IdentifierInfo *II,
                                      Preprocessor &PP,
                                      ConstSearchDirIterator LookupFrom,
                                      const FileEntry *LookupFromFile) {
+  // PASTA PATCH: Visibility into macro expansion.
+  PPCallbacks *Callbacks = PP.getPPCallbacks();
+  Token SavedIdentifier = Tok;
+  SavedIdentifier.setIdentifierInfo(II);
+  MacroDefinition MD = PP.getMacroDefinition(II);
+  MacroInfo *MI = MD.getMacroInfo();
+  if (Callbacks) {
+    Callbacks->Event(SavedIdentifier, PPCallbacks::BeginMacroCallArgumentList,
+                     reinterpret_cast<uintptr_t>(MI));
+  }
+
   // Save the location of the current token.  If a '(' is later found, use
   // that location.  If not, use the end of this location instead.
   SourceLocation LParenLoc = Tok.getLocation();
@@ -1201,6 +1362,8 @@ static bool EvaluateHasIncludeCommon(Token &Tok, IdentifierInfo *II,
       return false;
   } while (Tok.getKind() == tok::comment);
 
+  Token LParenTok = Tok;  // PASTA PATCH
+
   // Ensure we have a '('.
   if (Tok.isNot(tok::l_paren)) {
     // No '(', use end of last token.
@@ -1211,6 +1374,10 @@ static bool EvaluateHasIncludeCommon(Token &Tok, IdentifierInfo *II,
     if (Tok.isNot(tok::header_name))
       return false;
   } else {
+    if (Callbacks) {  // PASTA PATCH
+      Callbacks->Event(LParenTok, PPCallbacks::BeginMacroCallArgument,
+                       reinterpret_cast<uintptr_t>(&SavedIdentifier));
+    }
     // Save '(' location for possible missing ')' message.
     LParenLoc = Tok.getLocation();
     if (PP.LexHeaderName(Tok))
@@ -1242,6 +1409,16 @@ static bool EvaluateHasIncludeCommon(Token &Tok, IdentifierInfo *II,
     return false;
   }
 
+  // PASTA PATCH
+  if (Callbacks) {
+    Callbacks->Event(LParenTok, PPCallbacks::EndMacroCallArgument,
+                     reinterpret_cast<uintptr_t>(&Tok));
+    Callbacks->Event(LParenTok, PPCallbacks::EndMacroCallArgumentList,
+                     0);
+    Callbacks->Event(SavedIdentifier, PPCallbacks::SwitchToExpansion,
+                     reinterpret_cast<uintptr_t>(MI));
+  }
+
   bool isAngled = PP.GetIncludeFilenameSpelling(Tok.getLocation(), Filename);
   // If GetIncludeFilenameSpelling set the start ptr to null, there was an
   // error.
@@ -1285,6 +1462,13 @@ static void EvaluateFeatureLikeBuiltinMacro(llvm::raw_svector_ostream& OS,
                                             llvm::function_ref<
                                               int(Token &Tok,
                                                   bool &HasLexedNextTok)> Op) {
+  // PASTA PATCH: Visibility into macro expansion.
+  PPCallbacks *Callbacks = PP.getPPCallbacks();
+  Token SavedIdentifier = Tok;
+  SavedIdentifier.setIdentifierInfo(II);
+  MacroDefinition MD = PP.getMacroDefinition(II);
+  MacroInfo *MI = MD.getMacroInfo();
+
   // Parse the initial '('.
   PP.LexUnexpandedToken(Tok);
   if (Tok.isNot(tok::l_paren)) {
@@ -1303,6 +1487,15 @@ static void EvaluateFeatureLikeBuiltinMacro(llvm::raw_svector_ostream& OS,
   SourceLocation LParenLoc = Tok.getLocation();
   std::optional<int> Result;
 
+  // PASTA PATCH
+  clang::Token ArgSepTok = Tok;
+  if (Callbacks) {
+    Callbacks->Event(SavedIdentifier, PPCallbacks::BeginMacroCallArgumentList,
+                     reinterpret_cast<uintptr_t>(MI));
+    Callbacks->Event(ArgSepTok, PPCallbacks::BeginMacroCallArgument,
+                     reinterpret_cast<uintptr_t>(&SavedIdentifier));
+  }
+
   Token ResultTok;
   bool SuppressDiagnostic = false;
   while (true) {
@@ -1322,6 +1515,15 @@ already_lexed:
         return;
 
       case tok::comma:
+        // PASTA PATCH
+        if (ParenDepth == 1 && Callbacks) {
+          Callbacks->Event(ArgSepTok, PPCallbacks::EndMacroCallArgument,
+                           reinterpret_cast<uintptr_t>(&Tok));
+          ArgSepTok = Tok;
+          Callbacks->Event(ArgSepTok, PPCallbacks::BeginMacroCallArgument,
+                           reinterpret_cast<uintptr_t>(&SavedIdentifier));
+        }
+
         if (!SuppressDiagnostic) {
           PP.Diag(Tok.getLocation(), diag::err_too_many_args_in_macro_invoc);
           SuppressDiagnostic = true;
@@ -1342,6 +1544,15 @@ already_lexed:
         if (--ParenDepth > 0)
           continue;
 
+        // PASTA PATCH
+        if (Callbacks) {
+          Callbacks->Event(ArgSepTok, PPCallbacks::EndMacroCallArgument,
+                           reinterpret_cast<uintptr_t>(&Tok));
+          Callbacks->Event(ArgSepTok, PPCallbacks::EndMacroCallArgumentList, 0);
+          Callbacks->Event(SavedIdentifier, PPCallbacks::SwitchToExpansion,
+                           reinterpret_cast<uintptr_t>(MI));
+        }
+
         // The last ')' has been reached; return the value if one found or
         // a diagnostic and a dummy value.
         if (Result) {
@@ -1513,7 +1724,22 @@ void Preprocessor::ExpandBuiltinMacro(Token &Tok) {
   bool IsAtStartOfLine = Tok.isAtStartOfLine();
   bool HasLeadingSpace = Tok.hasLeadingSpace();
 
+  // PASTA PATCH:
+  Token SavedIdentifier = Tok;
+  SavedIdentifier.setIdentifierInfo(II);
+  MacroDefinition MD = getMacroDefinition(II);
+  MacroInfo *MI = MD.getMacroInfo();
+  DeferExpansionEnd NotifyMacroEnd(PostLexAction, Callbacks.get(),
+                                   SavedIdentifier, MI);
+  auto SwitchToExpansion = [&] (void) {
+    if (Callbacks) {
+      Callbacks->Event(SavedIdentifier, PPCallbacks::SwitchToExpansion,
+                       reinterpret_cast<uintptr_t>(MI));
+    }
+  };
+
   if (II == Ident__LINE__) {
+    SwitchToExpansion();  // PASTA PATCH
     // C99 6.10.8: "__LINE__: The presumed line number (within the current
     // source file) of the current source line (an integer constant)".  This can
     // be affected by #line.
@@ -1536,6 +1762,7 @@ void Preprocessor::ExpandBuiltinMacro(Token &Tok) {
     Tok.setKind(tok::numeric_constant);
   } else if (II == Ident__FILE__ || II == Ident__BASE_FILE__ ||
              II == Ident__FILE_NAME__) {
+    SwitchToExpansion();  // PASTA PATCH
     // C99 6.10.8: "__FILE__: The presumed name of the current source file (a
     // character string literal)". This can be affected by #line.
     PresumedLoc PLoc = SourceMgr.getPresumedLoc(Tok.getLocation());
@@ -1575,6 +1802,7 @@ void Preprocessor::ExpandBuiltinMacro(Token &Tok) {
     }
     Tok.setKind(tok::string_literal);
   } else if (II == Ident__DATE__) {
+    SwitchToExpansion();  // PASTA PATCH
     Diag(Tok.getLocation(), diag::warn_pp_date_time);
     if (!DATELoc.isValid())
       ComputeDATE_TIME(DATELoc, TIMELoc, *this);
@@ -1585,6 +1813,7 @@ void Preprocessor::ExpandBuiltinMacro(Token &Tok) {
                                                  Tok.getLength()));
     return;
   } else if (II == Ident__TIME__) {
+    SwitchToExpansion();  // PASTA PATCH
     Diag(Tok.getLocation(), diag::warn_pp_date_time);
     if (!TIMELoc.isValid())
       ComputeDATE_TIME(DATELoc, TIMELoc, *this);
@@ -1595,6 +1824,7 @@ void Preprocessor::ExpandBuiltinMacro(Token &Tok) {
                                                  Tok.getLength()));
     return;
   } else if (II == Ident__INCLUDE_LEVEL__) {
+    SwitchToExpansion();  // PASTA PATCH
     // Compute the presumed include depth of this token.  This can be affected
     // by GNU line markers.
     unsigned Depth = 0;
@@ -1610,6 +1840,7 @@ void Preprocessor::ExpandBuiltinMacro(Token &Tok) {
     OS << Depth;
     Tok.setKind(tok::numeric_constant);
   } else if (II == Ident__TIMESTAMP__) {
+    SwitchToExpansion();  // PASTA PATCH
     Diag(Tok.getLocation(), diag::warn_pp_date_time);
     // MSVC, ICC, GCC, VisualAge C++ extension.  The generated string should be
     // of the form "Ddd Mmm dd hh::mm::ss yyyy", which is returned by asctime.
@@ -1636,6 +1867,7 @@ void Preprocessor::ExpandBuiltinMacro(Token &Tok) {
     OS << '"' << StringRef(Result).drop_back() << '"';
     Tok.setKind(tok::string_literal);
   } else if (II == Ident__FLT_EVAL_METHOD__) {
+    SwitchToExpansion();  // PASTA PATCH
     // __FLT_EVAL_METHOD__ is set to the default value.
     OS << getTUFPEvalMethod();
     // __FLT_EVAL_METHOD__ expands to a simple numeric value.
@@ -1647,6 +1879,7 @@ void Preprocessor::ExpandBuiltinMacro(Token &Tok) {
       Diag(getLastFPEvalPragmaLocation(), diag::note_pragma_entered_here);
     }
   } else if (II == Ident__COUNTER__) {
+    SwitchToExpansion();  // PASTA PATCH
     // __COUNTER__ expands to a simple numeric value.
     OS << CounterValue++;
     Tok.setKind(tok::numeric_constant);
@@ -1848,6 +2081,7 @@ void Preprocessor::ExpandBuiltinMacro(Token &Tok) {
                (II->getName() == getLangOpts().CurrentModule);
       });
   } else if (II == Ident__MODULE__) {
+    SwitchToExpansion();  // PASTA PATCH
     // The current module as an identifier.
     OS << getLangOpts().CurrentModule;
     IdentifierInfo *ModuleII = getIdentifierInfo(getLangOpts().CurrentModule);
@@ -1856,6 +2090,12 @@ void Preprocessor::ExpandBuiltinMacro(Token &Tok) {
   } else if (II == Ident__identifier) {
     SourceLocation Loc = Tok.getLocation();
 
+    // PASTA PATCH
+    if (Callbacks) {
+      Callbacks->Event(SavedIdentifier, PPCallbacks::BeginMacroCallArgumentList,
+                       0);
+    }
+
     // We're expecting '__identifier' '(' identifier ')'. Try to recover
     // if the parens are missing.
     LexNonComment(Tok);
@@ -1869,6 +2109,13 @@ void Preprocessor::ExpandBuiltinMacro(Token &Tok) {
       return;
     }
 
+    // PASTA PATCH
+    Token LParenTok = Tok;
+    if (Callbacks) {
+      Callbacks->Event(LParenTok, PPCallbacks::BeginMacroCallArgument,
+                       reinterpret_cast<uintptr_t>(&SavedIdentifier));
+    }
+
     SourceLocation LParenLoc = Tok.getLocation();
     LexNonComment(Tok);
 
@@ -1897,6 +2144,15 @@ void Preprocessor::ExpandBuiltinMacro(Token &Tok) {
         << Tok.getKind() << tok::r_paren;
       Diag(LParenLoc, diag::note_matching) << tok::l_paren;
     }
+
+    // PASTA PATCH
+    if (Callbacks) {
+      Callbacks->Event(LParenTok, PPCallbacks::EndMacroCallArgument,
+                       reinterpret_cast<uintptr_t>(&Tok));
+      Callbacks->Event(Tok, PPCallbacks::EndMacroCallArgumentList, 0);
+    }
+    SwitchToExpansion();  // PASTA PATCH
+
     return;
   } else if (II == Ident__is_target_arch) {
     EvaluateFeatureLikeBuiltinMacro(
diff --git a/clang/lib/Lex/Pragma.cpp b/clang/lib/Lex/Pragma.cpp
index 4da9d1603..5a18f5220 100644
--- a/clang/lib/Lex/Pragma.cpp
+++ b/clang/lib/Lex/Pragma.cpp
@@ -29,6 +29,7 @@
 #include "clang/Lex/MacroInfo.h"
 #include "clang/Lex/ModuleLoader.h"
 #include "clang/Lex/PPCallbacks.h"
+#include "clang/Lex/PPCallbacksEventKind.h"  // PASTA PATCH
 #include "clang/Lex/Preprocessor.h"
 #include "clang/Lex/PreprocessorLexer.h"
 #include "clang/Lex/PreprocessorOptions.h"
@@ -207,10 +208,27 @@ void Preprocessor::Handle_Pragma(Token &Tok) {
   // In Case #2, we check the syntax now, but then put the tokens back into the
   // token stream for later consumption.
 
+  // PASTA PATCH
+  // If we're expanding a macro argument, let the checking and subsequent lexing
+  // happen, but tell the listener that we're going to be cancelling this.
+  Token SavedIdentifier = Tok;
+  MacroDefinition MD = getMacroDefinition(Tok.getIdentifierInfo());
+  MacroInfo *MI = MD.getMacroInfo();
+  if (Callbacks) {
+    if (InMacroArgPreExpansion) {
+      Callbacks->Event(SavedIdentifier, PPCallbacks::PrepareToCancelExpansion,
+                       reinterpret_cast<uintptr_t>(MI));
+    } else {
+      Callbacks->Event(SavedIdentifier, PPCallbacks::BeginMacroCallArgumentList,
+                       reinterpret_cast<uintptr_t>(MI));
+    }
+  }
+
   TokenCollector Toks = {*this, InMacroArgPreExpansion, {}, Tok};
 
   // Remember the pragma token location.
   SourceLocation PragmaLoc = Tok.getLocation();
+  SourceLocation PragmaEndLoc = Tok.getEndLoc();  // PASTA PATCH
 
   // Read the '('.
   Toks.lex();
@@ -219,6 +237,13 @@ void Preprocessor::Handle_Pragma(Token &Tok) {
     return;
   }
 
+  // PASTA PATCH
+  Token LParenTok = Tok;
+  if (Callbacks && !InMacroArgPreExpansion) {
+    Callbacks->Event(LParenTok, PPCallbacks::BeginMacroCallArgument,
+                     reinterpret_cast<uintptr_t>(&SavedIdentifier));
+  }
+
   // Read the '"..."'.
   Toks.lex();
   if (!tok::isStringLiteral(Tok.getKind())) {
@@ -254,8 +279,43 @@ void Preprocessor::Handle_Pragma(Token &Tok) {
     return;
   }
 
+  // PASTA PATCH: Go and simulate the directive events that would have happened
+  // if this had been an actual `#pragma` directive.
+  Token HashTok;
+  Token PragmaDirectiveTok;
+  if (Callbacks && !InMacroArgPreExpansion) {
+    Callbacks->Event(LParenTok, PPCallbacks::EndMacroCallArgument,
+                     reinterpret_cast<uintptr_t>(&Tok));
+    Callbacks->Event(LParenTok, PPCallbacks::EndMacroCallArgumentList, 0);
+    Callbacks->Event(SavedIdentifier, PPCallbacks::SwitchToExpansion,
+                     reinterpret_cast<uintptr_t>(MI));
+
+    HashTok.startToken();
+    HashTok.setKind(tok::hash);
+    CreateString("#", HashTok, PragmaLoc,
+                 PragmaLoc.getLocWithOffset(1));
+    HashTok.setLength(1u);
+    Callbacks->Event(HashTok, PPCallbacks::BeginDirective, 0);
+
+    PragmaDirectiveTok.startToken();
+    PragmaDirectiveTok.setKind(tok::raw_identifier);
+    CreateString("pragma", PragmaDirectiveTok, PragmaLoc.getLocWithOffset(1),
+                 PragmaEndLoc);
+    Callbacks->Event(PragmaDirectiveTok, PPCallbacks::TokenFromLexer, 0);
+    Callbacks->Event(HashTok, PPCallbacks::SetNamedDirective,
+                     reinterpret_cast<uintptr_t>(&PragmaDirectiveTok));
+  }
+
   // If we're expanding a macro argument, put the tokens back.
   if (InMacroArgPreExpansion) {
+    if (Callbacks) {  // PASTA PATCH
+//      Token EOD;
+//      EOD.startToken();
+//      EOD.setKind(tok::eod);
+//      Callbacks->Event(EOD, PPCallbacks::EndNonDirective, 0);
+      Callbacks->Event(SavedIdentifier, PPCallbacks::CancelExpansion,
+                       reinterpret_cast<uintptr_t>(MI));
+    }
     Toks.revert();
     return;
   }
@@ -1984,10 +2044,13 @@ static IdentifierInfo *HandleMacroAnnotationPragma(Preprocessor &PP, Token &Tok,
   }
   IdentifierInfo *II = Tok.getIdentifierInfo();
 
-  if (!II->hasMacroDefinition()) {
-    PP.Diag(Tok, diag::err_pp_visibility_non_macro) << II;
-    return nullptr;
-  }
+  // PASTA PATCH: PASTA's two-pass pre-processing means that macros won't end
+  //              up being explicitly represented in the second pass, and so
+  //              this error will always trigger.
+  // if (!II->hasMacroDefinition()) {
+  //   PP.Diag(Tok, diag::err_pp_visibility_non_macro) << II;
+  //   return nullptr;
+  // }
 
   PP.Lex(Tok);
   if (Tok.is(tok::comma)) {
@@ -2001,6 +2064,11 @@ static IdentifierInfo *HandleMacroAnnotationPragma(Preprocessor &PP, Token &Tok,
     PP.Diag(Tok, diag::err_expected) << ")";
     return nullptr;
   }
+
+  if (!II->hasMacroDefinition()) {
+    return nullptr;  // PASTA PATCH (see above)
+  }
+
   return II;
 }
 
diff --git a/clang/lib/Lex/Preprocessor.cpp b/clang/lib/Lex/Preprocessor.cpp
index 0d411abf8..03e08ac24 100644
--- a/clang/lib/Lex/Preprocessor.cpp
+++ b/clang/lib/Lex/Preprocessor.cpp
@@ -44,6 +44,7 @@
 #include "clang/Lex/MacroArgs.h"
 #include "clang/Lex/MacroInfo.h"
 #include "clang/Lex/ModuleLoader.h"
+#include "clang/Lex/PPCallbacksEventKind.h"  // PASTA PATCH
 #include "clang/Lex/Pragma.h"
 #include "clang/Lex/PreprocessingRecord.h"
 #include "clang/Lex/PreprocessorLexer.h"
@@ -92,6 +93,7 @@ Preprocessor::Preprocessor(std::shared_ptr<PreprocessorOptions> PPOpts,
       Identifiers(IILookup), PragmaHandlers(new PragmaNamespace(StringRef())),
       TUKind(TUKind), SkipMainFilePreamble(0, true),
       CurSubmoduleState(&NullSubmoduleState) {
+  PostLexAction = [] (const Token &) {};  // PASTA PATCH
   OwnsHeaderSearch = OwnsHeaders;
 
   // Default to discarding comments.
@@ -682,9 +684,17 @@ void Preprocessor::replayPreambleConditionalStack() {
            "CurPPLexer is null when calling replayPreambleConditionalStack.");
     CurPPLexer->setConditionalLevels(PreambleConditionalStack.getStack());
     PreambleConditionalStack.doneReplaying();
+
+    // PASTA PATCH
+    Token HashToken;
+    HashToken.startToken();
+    HashToken.setKind(tok::hash);
+    HashToken.setLocation(PreambleConditionalStack.SkipInfo->HashTokenLoc);
+    HashToken.setLength(1u);
+
     if (PreambleConditionalStack.reachedEOFWhileSkipping())
       SkipExcludedConditionalBlock(
-          PreambleConditionalStack.SkipInfo->HashTokenLoc,
+          HashToken,  // PASTA PATCH
           PreambleConditionalStack.SkipInfo->IfTokenLoc,
           PreambleConditionalStack.SkipInfo->FoundNonSkipPortion,
           PreambleConditionalStack.SkipInfo->FoundElse,
@@ -878,27 +888,59 @@ bool Preprocessor::HandleIdentifier(Token &Identifier) {
 void Preprocessor::Lex(Token &Result) {
   ++LexLevel;
 
+  auto InputRawLoc = Result.getLocation().getRawEncoding();  // PASTA PATCH
+
   // We loop here until a lex function returns a token; this avoids recursion.
   bool ReturnedToken;
   do {
     switch (CurLexerKind) {
     case CLK_Lexer:
       ReturnedToken = CurLexer->Lex(Result);
+
+      // PASTA PATCH: Visibility into all tokens.
+      if (ReturnedToken && Callbacks) {
+        Callbacks->Event(Result, PPCallbacks::TokenFromLexer, InputRawLoc);
+      }
       break;
     case CLK_TokenLexer:
       ReturnedToken = CurTokenLexer->Lex(Result);
+
+      // PASTA PATCH: Visibility into all tokens.
+      if (ReturnedToken && Callbacks) {
+        Callbacks->Event(Result, PPCallbacks::TokenFromTokenLexer, InputRawLoc);
+      }
       break;
     case CLK_CachingLexer:
       CachingLex(Result);
       ReturnedToken = true;
+
+      // PASTA PATCH: Visibility into all tokens.
+      if (ReturnedToken && Callbacks) {
+        Callbacks->Event(Result, PPCallbacks::TokenFromCachingLexer,
+                         InputRawLoc);
+      }
       break;
     case CLK_DependencyDirectivesLexer:
       ReturnedToken = CurLexer->LexDependencyDirectiveToken(Result);
       break;
     case CLK_LexAfterModuleImport:
       ReturnedToken = LexAfterModuleImport(Result);
+
+      // PASTA PATCH: Visibility into all tokens.
+      if (ReturnedToken && Callbacks) {
+        Callbacks->Event(Result, PPCallbacks::TokenFromAfterModuleImportLexer,
+                         InputRawLoc);
+      }
       break;
     }
+
+    // PASTA PATCH
+    if (ReturnedToken && Callbacks && Result.is(tok::eod)) {
+      Callbacks->Event(Result, PPCallbacks::EndDirective, 0);
+    }
+    PostLexAction(Result);
+    PostLexAction = [] (const Token &) {};
+
   } while (!ReturnedToken);
 
   if (Result.is(tok::unknown) && TheModuleLoader.HadFatalFailure)
diff --git a/clang/lib/Lex/TokenLexer.cpp b/clang/lib/Lex/TokenLexer.cpp
index ebe7dd66c..d3382d3c3 100644
--- a/clang/lib/Lex/TokenLexer.cpp
+++ b/clang/lib/Lex/TokenLexer.cpp
@@ -21,6 +21,7 @@
 #include "clang/Lex/Lexer.h"
 #include "clang/Lex/MacroArgs.h"
 #include "clang/Lex/MacroInfo.h"
+#include "clang/Lex/PPCallbacksEventKind.h"  // PASTA PATCH
 #include "clang/Lex/Preprocessor.h"
 #include "clang/Lex/Token.h"
 #include "clang/Lex/VariadicMacroSupport.h"
@@ -35,6 +36,16 @@
 
 using namespace clang;
 
+// PASTA PATCH
+static const Token &TokenReference(const Token *Ptr, size_t NumToks) {
+  if (Ptr && NumToks) {
+    return *Ptr;
+  } else {
+    static const Token kInvalidToken{};
+    return kInvalidToken;
+  }
+}
+
 /// Create a TokenLexer for the specified macro with the specified actual
 /// arguments.  Note that this ctor takes ownership of the ActualArgs pointer.
 void TokenLexer::Init(Token &Tok, SourceLocation ELEnd, MacroInfo *MI,
@@ -43,6 +54,8 @@ void TokenLexer::Init(Token &Tok, SourceLocation ELEnd, MacroInfo *MI,
   // associated with it.
   destroy();
 
+  MacroNameTok = Tok;  // PASTA PATCH
+
   Macro = MI;
   ActualArgs = Actuals;
   CurTokenIdx = 0;
@@ -82,8 +95,42 @@ void TokenLexer::Init(Token &Tok, SourceLocation ELEnd, MacroInfo *MI,
 
   // If this is a function-like macro, expand the arguments and change
   // Tokens to point to the expanded tokens.
-  if (Macro->isFunctionLike() && Macro->getNumParams())
+  if (Macro->isFunctionLike() && Macro->getNumParams()) {  // PASTA PATCH
+    auto Callbacks = PP.getPPCallbacks();
+    if (ActualArgs && Callbacks) {
+      unsigned NumArgs = ActualArgs->getNumMacroArguments();
+      if (NumArgs && Macro->isVariadic() && ActualArgs->isVarargsElidedUse()) {
+        NumArgs -= 1u;  // Last argument is `VariadicArgIndex`.
+      }
+
+      // In theory we only need to pre-expand what needs pre-expansion. In
+      // practice, Clang goes and sometimes requests pre-expansion for the
+      // sake of figuring out __VA_OPT__ stuff, via the
+      // `MacroArgs::invokedWithVariadicArgument` function.
+      Callbacks->Event(MacroNameTok, PPCallbacks::BeginPreArgumentExpansion,
+                       reinterpret_cast<uintptr_t>(Macro));
+
+      // Pre expand each argument, which internally caches the results.
+      for (unsigned ArgNo = 0; ArgNo < NumArgs; ++ArgNo) {
+        Callbacks->Event(MacroNameTok, PPCallbacks::BeginMacroCallArgument, 0);
+        (void) ActualArgs->getPreExpArgument(ArgNo, PP);
+        Callbacks->Event(MacroNameTok, PPCallbacks::EndMacroCallArgument, 0);
+      }
+
+      Callbacks->Event(MacroNameTok, PPCallbacks::EndPreArgumentExpansion,
+                       reinterpret_cast<uintptr_t>(Macro));
+    }
+    if (Callbacks) {  // PASTA PATCH
+      Callbacks->Event(MacroNameTok, PPCallbacks::BeforeParameterSubstitutions,
+                       NumTokens);
+    }
     ExpandFunctionArguments();
+    if (Callbacks) {  // PASTA PATCH
+      Callbacks->Event(TokenReference(Tokens, NumTokens),
+                       PPCallbacks::AfterParameterSubstitutions,
+                       NumTokens);
+    }
+  }  // PASTA PATCH
 
   // Mark the macro as currently disabled, so that it is not recursively
   // expanded.  The macro must be disabled only after argument pre-expansion of
@@ -166,6 +213,14 @@ bool TokenLexer::MaybeRemoveCommaBeforeVaArgs(
   if (HasPasteOperator)
     PP.Diag(ResultToks.back().getLocation(), diag::ext_paste_comma);
 
+  auto Callbacks = PP.getPPCallbacks();  // PASTA PATCH
+  if (Callbacks) {
+    Callbacks->Event(
+        TokenReference(ResultToks.data(), ResultToks.size()),
+        PPCallbacks::BeforeRemoveCommas,
+        reinterpret_cast<uintptr_t>(ResultToks.size()));
+  }
+
   // Remove the comma.
   ResultToks.pop_back();
 
@@ -181,6 +236,13 @@ bool TokenLexer::MaybeRemoveCommaBeforeVaArgs(
     ResultToks.back().setFlag(Token::CommaAfterElided);
   }
 
+  if (Callbacks) {  // PASTA PATCH
+    Callbacks->Event(
+        TokenReference(ResultToks.data(), ResultToks.size()),
+        PPCallbacks::AfterRemoveCommas,
+        reinterpret_cast<uintptr_t>(ResultToks.size()));
+  }
+
   // Never add a space, even if the comma, ##, or arg had a space.
   NextTokGetsSpace = false;
   return true;
@@ -253,6 +315,8 @@ void TokenLexer::ExpandFunctionArguments() {
 
   VAOptExpansionContext VCtx(PP);
 
+  auto Callbacks = PP.getPPCallbacks();  // PASTA PATCH
+
   for (unsigned I = 0, E = NumTokens; I != E; ++I) {
     const Token &CurTok = Tokens[I];
     // We don't want a space for the next token after a paste
@@ -269,6 +333,17 @@ void TokenLexer::ExpandFunctionArguments() {
       assert(Tokens[I + 1].is(tok::l_paren) &&
              "__VA_OPT__ must be followed by '('");
 
+      if (Callbacks) {  // PASTA PATCH
+        ResultToks.push_back(CurTok);
+        ResultToks.push_back(Tokens[I + 1]);
+        Callbacks->Event(
+            TokenReference(ResultToks.data(), ResultToks.size()),
+            PPCallbacks::BeforeVAOpt,
+            reinterpret_cast<uintptr_t>(ResultToks.size()));
+        ResultToks.pop_back();
+        ResultToks.pop_back();
+      }
+
       ++I;             // Skip the l_paren
       VCtx.sawVAOptFollowedByOpeningParens(CurTok.getLocation(),
                                            ResultToks.size());
@@ -302,12 +377,24 @@ void TokenLexer::ExpandFunctionArguments() {
               ActualArgs->invokedWithVariadicArgument(Macro, PP);
         }
         if (!*CalledWithVariadicArguments) {
+          if (Callbacks) {  // PASTA PATCH
+            Callbacks->Event(CurTok, PPCallbacks::SkippedVAOptToken, 0u);
+          }
+
           // Skip this token.
           continue;
         }
         // ... else the macro was called with variadic arguments, and we do not
         // have a closing rparen - so process this token normally.
       } else {
+        if (Callbacks) {  // PASTA PATCH
+          ResultToks.push_back(CurTok);
+          Callbacks->Event(
+              TokenReference(ResultToks.data(), ResultToks.size()),
+              PPCallbacks::AfterVAOpt,
+              reinterpret_cast<uintptr_t>(ResultToks.size()));
+          ResultToks.pop_back();
+        }
         // Current token is the closing r_paren which marks the end of the
         // __VA_OPT__ invocation, so handle any place-marker pasting (if
         // empty) by removing hashhash either before (if exists) or after. And
@@ -323,6 +410,12 @@ void TokenLexer::ExpandFunctionArguments() {
           // is a token that represents an empty string.
           stringifyVAOPTContents(ResultToks, VCtx,
                                  /*ClosingParenLoc*/ Tokens[I].getLocation());
+          if (Callbacks) {  // PASTA PATCH
+            Callbacks->Event(
+                TokenReference(ResultToks.data(), ResultToks.size()),
+                PPCallbacks::AfterStringify,
+                reinterpret_cast<uintptr_t>(ResultToks.size()));
+          }
 
         } else if (/*No tokens within VAOPT*/
                    ResultToks.size() == VCtx.getNumberOfTokensPriorToVAOpt()) {
@@ -369,6 +462,15 @@ void TokenLexer::ExpandFunctionArguments() {
     // parameter or __VA_OPT__ when the #define was lexed.
 
     if (CurTok.isOneOf(tok::hash, tok::hashat)) {
+      if (Callbacks) {  // PASTA PATCH
+        ResultToks.push_back(CurTok);
+        Callbacks->Event(
+            TokenReference(ResultToks.data(), ResultToks.size()),
+            PPCallbacks::BeforeStringify,
+            reinterpret_cast<uintptr_t>(ResultToks.size()));
+        ResultToks.pop_back();
+      }
+
       int ArgNo = Macro->getParameterNum(Tokens[I+1].getIdentifierInfo());
       assert((ArgNo != -1 || VCtx.isVAOptToken(Tokens[I + 1])) &&
              "Token following # is not an argument or __VA_OPT__!");
@@ -396,7 +498,36 @@ void TokenLexer::ExpandFunctionArguments() {
       if (NextTokGetsSpace)
         Res.setFlag(Token::LeadingSpace);
 
+      if (Callbacks) {  // PASTA PATCH
+        ResultToks.push_back(Tokens[I+1]);  // Parameter name.
+        Callbacks->Event(
+            TokenReference(ResultToks.data(), ResultToks.size()),
+            PPCallbacks::BeforeMacroParameterUse,
+            reinterpret_cast<uintptr_t>(ResultToks.size()));
+        ResultToks.pop_back();
+        auto OldSize = ResultToks.size();
+
+        // Render the argument tokens.
+        for (auto ParamArgToks = UnexpArg; ParamArgToks->isNot(tok::eof);
+             ++ParamArgToks) {
+          ResultToks.push_back(*ParamArgToks);  // Argument token.
+        }
+        Callbacks->Event(
+            TokenReference(ResultToks.data(), ResultToks.size()),
+            PPCallbacks::AfterMacroParameterUse,
+            reinterpret_cast<uintptr_t>(ResultToks.size()));
+        ResultToks.resize(OldSize);
+      }
+
       ResultToks.push_back(Res);
+
+      if (Callbacks) { // PASTA PATCH
+        Callbacks->Event(
+            TokenReference(ResultToks.data(), ResultToks.size()),
+            PPCallbacks::AfterStringify,
+            reinterpret_cast<uintptr_t>(ResultToks.size()));
+      }
+
       MadeChange = true;
       ++I;  // Skip arg name.
       NextTokGetsSpace = false;
@@ -430,6 +561,13 @@ void TokenLexer::ExpandFunctionArguments() {
       continue;
     }
 
+    if (PasteAfter && Callbacks) {  // PASTA PATCH
+      Callbacks->Event(
+          TokenReference(ResultToks.data(), ResultToks.size()),
+          PPCallbacks::BeforeConcatenation,
+          reinterpret_cast<uintptr_t>(ResultToks.size()));
+    }
+
     // An argument is expanded somehow, the result is different than the
     // input.
     MadeChange = true;
@@ -444,6 +582,16 @@ void TokenLexer::ExpandFunctionArguments() {
                                      Macro, ArgNo, PP))
       continue;
 
+
+    if (Callbacks) {  // PASTA PATCH
+      ResultToks.push_back(CurTok);
+      Callbacks->Event(
+          TokenReference(ResultToks.data(), ResultToks.size()),
+          PPCallbacks::BeforeMacroParameterUse,
+          reinterpret_cast<uintptr_t>(ResultToks.size()));
+      ResultToks.pop_back();
+    }
+
     // If it is not the LHS/RHS of a ## operator, we must pre-expand the
     // argument and substitute the expanded tokens into the result.  This is
     // C99 6.10.3.1p1.
@@ -453,7 +601,7 @@ void TokenLexer::ExpandFunctionArguments() {
       // Only preexpand the argument if it could possibly need it.  This
       // avoids some work in common cases.
       const Token *ArgTok = ActualArgs->getUnexpArgument(ArgNo);
-      if (ActualArgs->ArgNeedsPreexpansion(ArgTok, PP))
+      if (Callbacks || ActualArgs->ArgNeedsPreexpansion(ArgTok, PP))  // PASTA PATCH
         ResultArgToks = &ActualArgs->getPreExpArgument(ArgNo, PP)[0];
       else
         ResultArgToks = ArgTok;  // Use non-preexpanded tokens.
@@ -504,6 +652,14 @@ void TokenLexer::ExpandFunctionArguments() {
         if (RParenAfter)
           VCtx.hasPlaceholderBeforeRParen();
       }
+
+      if (Callbacks) {  // PASTA PATCH
+        Callbacks->Event(
+            TokenReference(ResultToks.data(), ResultToks.size()),
+            PPCallbacks::AfterMacroParameterUse,
+            reinterpret_cast<uintptr_t>(ResultToks.size()));
+      }
+
       continue;
     }
 
@@ -552,10 +708,38 @@ void TokenLexer::ExpandFunctionArguments() {
             Token::LeadingSpace, NextTokGetsSpace);
       }
 
+      if (Callbacks) {  // PASTA PATCH
+        Callbacks->Event(
+            TokenReference(ResultToks.data(), ResultToks.size()),
+            PPCallbacks::AfterMacroParameterUse,
+            reinterpret_cast<uintptr_t>(ResultToks.size()));
+
+        if (PasteBefore) {
+          Callbacks->Event(
+              TokenReference(ResultToks.data(), ResultToks.size()),
+              PPCallbacks::AfterConcatenation,
+              reinterpret_cast<uintptr_t>(ResultToks.size()));
+        }
+      }
+
       NextTokGetsSpace = false;
       continue;
     }
 
+    if (Callbacks) {  // PASTA PATCH
+      Callbacks->Event(
+          TokenReference(ResultToks.data(), ResultToks.size()),
+          PPCallbacks::AfterMacroParameterUse,
+          reinterpret_cast<uintptr_t>(ResultToks.size()));
+
+      if (PasteBefore) {
+          Callbacks->Event(
+              TokenReference(ResultToks.data(), ResultToks.size()),
+              PPCallbacks::AfterConcatenation,
+              reinterpret_cast<uintptr_t>(ResultToks.size()));
+        }
+    }
+
     // If an empty argument is on the LHS or RHS of a paste, the standard (C99
     // 6.10.3.3p2,3) calls for a bunch of placemarker stuff to occur.  We
     // implement this by eating ## operators when a LHS or RHS expands to
@@ -581,9 +765,9 @@ void TokenLexer::ExpandFunctionArguments() {
       // of removing the paste operator if __VA_OPT__ reduces to the notional
       // placemarker above when we encounter the closing paren of VA_OPT.
       if (!VCtx.isInVAOpt() ||
-          ResultToks.size() > VCtx.getNumberOfTokensPriorToVAOpt())
+          ResultToks.size() > VCtx.getNumberOfTokensPriorToVAOpt()) {
         ResultToks.pop_back();
-      else
+      } else
         VCtx.hasPlaceholderAfterHashhashAtStart();
     }
 
@@ -627,6 +811,12 @@ bool TokenLexer::Lex(Token &Tok) {
     // that it is no longer being expanded.
     if (Macro) Macro->EnableMacro();
 
+//    // PASTA PATCH
+//    if (Macro && Callbacks) {
+//      Callbacks->Event(MacroNameTok, PPCallbacks::EndMacroExpansion,
+//                          reinterpret_cast<uintptr_t>(Macro));
+//    }
+
     Tok.startToken();
     Tok.setFlagValue(Token::StartOfLine , AtStartOfLine);
     Tok.setFlagValue(Token::LeadingSpace, HasLeadingSpace || NextTokGetsSpace);
@@ -657,9 +847,20 @@ bool TokenLexer::Lex(Token &Tok) {
        // 'L#macro_arg' construct in a function-like macro.
        (PP.getLangOpts().MSVCCompat &&
         isWideStringLiteralFromMacro(Tok, Tokens[CurTokenIdx])))) {
+
+    auto Callbacks = PP.getPPCallbacks();  // PASTA PATCH
+    if (Callbacks) {
+      Callbacks->Event(Tok, PPCallbacks::BeginConcatenation,
+                       reinterpret_cast<uintptr_t>(&(Tokens[CurTokenIdx])));
+    }
+
     // When handling the microsoft /##/ extension, the final token is
     // returned by pasteTokens, not the pasted token.
-    if (pasteTokens(Tok))
+    auto PasteIsSimple = pasteTokens(Tok);  // PASTA PATCH
+    if (Callbacks) {
+      Callbacks->Event(Tok, PPCallbacks::EndConcatenation, 0);
+    }
+    if (PasteIsSimple)
       return true;
 
     TokenIsFromPaste = true;
@@ -755,6 +956,8 @@ bool TokenLexer::pasteTokens(Token &LHSTok, ArrayRef<Token> TokenStream,
     return TokenStream.size() == CurIdx;
   };
 
+  auto Callbacks = PP.getPPCallbacks();  // PASTA PATCH
+
   do {
     // Consume the ## operator if any.
     PasteOpLoc = TokenStream[CurIdx].getLocation();
@@ -765,6 +968,19 @@ bool TokenLexer::pasteTokens(Token &LHSTok, ArrayRef<Token> TokenStream,
     // Get the RHS token.
     const Token &RHS = TokenStream[CurIdx];
 
+    if (Callbacks) {  // PASTA PATCH
+      if (CurIdx && TokenStream[CurIdx - 1u].is(tok::hashhash)) {
+        Callbacks->Event(
+            TokenStream[CurIdx - 1u],
+            PPCallbacks::ConcatenationOperatorToken,
+            reinterpret_cast<uintptr_t>(&LHSTok)); 
+      }
+      Callbacks->Event(
+          RHS,
+          PPCallbacks::ConcatenationAccumulationToken,
+          reinterpret_cast<uintptr_t>(&LHSTok));
+    }
+
     // Allocate space for the result token.  This is guaranteed to be enough for
     // the two tokens.
     Buffer.resize(LHSTok.getLength() + RHS.getLength());
diff --git a/clang/lib/Parse/ParseExpr.cpp b/clang/lib/Parse/ParseExpr.cpp
index 66d937ac5..99eeabfea 100644
--- a/clang/lib/Parse/ParseExpr.cpp
+++ b/clang/lib/Parse/ParseExpr.cpp
@@ -1436,6 +1436,13 @@ ExprResult Parser::ParseCastExpression(CastParseKind ParseKind,
   case tok::kw_sizeof:     // unary-expression: 'sizeof' unary-expression
                            // unary-expression: 'sizeof' '(' type-name ')'
   case tok::kw_vec_step:   // unary-expression: OpenCL 'vec_step' expression
+
+  // PASTA PATCH: XNU-specific UETTs.
+  case tok::kw___builtin_ptrauth_type_discriminator:
+  case tok::kw___builtin_xnu_type_signature:
+  case tok::kw___builtin_xnu_type_summary:
+  case tok::kw___builtin_tmo_type_get_metadata:
+
   // unary-expression: '__builtin_omp_required_simd_align' '(' type-name ')'
   case tok::kw___builtin_omp_required_simd_align:
     if (NotPrimaryExpression)
@@ -2311,7 +2318,12 @@ Parser::ParseExprAfterUnaryExprOrTypeTrait(const Token &OpTok,
   assert(OpTok.isOneOf(tok::kw_typeof, tok::kw_typeof_unqual, tok::kw_sizeof,
                        tok::kw___alignof, tok::kw_alignof, tok::kw__Alignof,
                        tok::kw_vec_step,
-                       tok::kw___builtin_omp_required_simd_align) &&
+                       tok::kw___builtin_omp_required_simd_align,
+                       // PASTA PATCH: XNU-specific UETTs.
+                       tok::kw___builtin_ptrauth_type_discriminator,
+                       tok::kw___builtin_xnu_type_signature,
+                       tok::kw___builtin_xnu_type_summary,
+                       tok::kw___builtin_tmo_type_get_metadata) &&
          "Not a typeof/sizeof/alignof/vec_step expression!");
 
   ExprResult Operand;
@@ -2432,7 +2444,13 @@ ExprResult Parser::ParseSYCLUniqueStableNameExpression() {
 ExprResult Parser::ParseUnaryExprOrTypeTraitExpression() {
   assert(Tok.isOneOf(tok::kw_sizeof, tok::kw___alignof, tok::kw_alignof,
                      tok::kw__Alignof, tok::kw_vec_step,
-                     tok::kw___builtin_omp_required_simd_align) &&
+                     tok::kw___builtin_omp_required_simd_align,
+
+                     // PASTA PATCH: XNU-specific UETTs.
+                     tok::kw___builtin_ptrauth_type_discriminator,
+                     tok::kw___builtin_xnu_type_signature,
+                     tok::kw___builtin_xnu_type_summary,
+                     tok::kw___builtin_tmo_type_get_metadata) &&
          "Not a sizeof/alignof/vec_step expression!");
   Token OpTok = Tok;
   ConsumeToken();
@@ -2509,6 +2527,16 @@ ExprResult Parser::ParseUnaryExprOrTypeTraitExpression() {
   else if (OpTok.is(tok::kw___builtin_omp_required_simd_align))
     ExprKind = UETT_OpenMPRequiredSimdAlign;
 
+  // PASTA PATCH: XNU-specific things.
+  else if (OpTok.is(tok::kw___builtin_ptrauth_type_discriminator))
+    ExprKind = UETT_PtrAuthTypeDiscriminator;
+  else if (OpTok.is(tok::kw___builtin_xnu_type_signature))
+    ExprKind = UETT_XNUTypeSignature;
+  else if (OpTok.is(tok::kw___builtin_xnu_type_summary))
+    ExprKind = UETT_XNUTypeSummary;
+  else if (OpTok.is(tok::kw___builtin_tmo_type_get_metadata))
+    ExprKind = UETT_TMOTypeGetMetadata;
+
   if (isCastExpr)
     return Actions.ActOnUnaryExprOrTypeTraitExpr(OpTok.getLocation(),
                                                  ExprKind,
diff --git a/clang/lib/Parse/ParseTemplate.cpp b/clang/lib/Parse/ParseTemplate.cpp
index 6fc67b696..6adea68b2 100644
--- a/clang/lib/Parse/ParseTemplate.cpp
+++ b/clang/lib/Parse/ParseTemplate.cpp
@@ -13,6 +13,7 @@
 #include "clang/AST/ASTContext.h"
 #include "clang/AST/DeclTemplate.h"
 #include "clang/AST/ExprCXX.h"
+#include "clang/Lex/PPCallbacksEventKind.h"  // PASTA PATCH
 #include "clang/Parse/ParseDiagnostic.h"
 #include "clang/Parse/Parser.h"
 #include "clang/Parse/RAIIObjectsForParser.h"
@@ -1225,6 +1226,13 @@ bool Parser::ParseGreaterThanInTemplateList(SourceLocation LAngleLoc,
     AfterGreaterLoc = PP.SplitToken(AfterGreaterLoc, Tok.getLength());
   Tok.setLocation(AfterGreaterLoc);
 
+  // PASTA PATCH: We want to observe when tokens are split up so that we can
+  //              have this reflected in PASTA's token lists.
+  if (PPCallbacks *Callbacks = PP.getPPCallbacks()) {
+    Callbacks->Event(Greater, PPCallbacks::BeginSplitToken, 0);
+    Callbacks->Event(Tok, PPCallbacks::EndSplitToken, 0);
+  }
+
   // Update the token cache to match what we just did if necessary.
   if (CachingTokens) {
     // If the previous cached token is being merged, delete it.
diff --git a/clang/lib/Sema/SemaDecl.cpp b/clang/lib/Sema/SemaDecl.cpp
index 051fad042..85b6cf20e 100644
--- a/clang/lib/Sema/SemaDecl.cpp
+++ b/clang/lib/Sema/SemaDecl.cpp
@@ -6340,6 +6340,11 @@ NamedDecl *Sema::HandleDeclarator(Scope *S, Declarator &D,
       Previous.setRedeclarationKind(ForExternalRedeclaration);
     }
 
+    // PASTA PATCH: Disable auto-creation of builtins from things like `atoi`;
+    //              it ends up leading to a lot of source location information
+    //              being dropped.
+    CreateBuiltins = CreateBuiltins ? false : false;
+
     LookupName(Previous, S, CreateBuiltins);
   } else { // Something like "int foo::x;"
     LookupQualifiedName(Previous, DC);
@@ -6534,6 +6539,13 @@ FixInvalidVariablyModifiedTypeLoc(TypeLoc SrcTL, TypeLoc DstTL) {
     DstPTL.setRParenLoc(SrcPTL.getRParenLoc());
     return;
   }
+
+  // PASTA PATCH: Might have an AdjustedTypeLoc for DstTL due to multiplier
+  //              patches for issue #130.
+  if (AdjustedTypeLoc AdjTL = DstTL.getAs<AdjustedTypeLoc>()) {
+    DstTL = AdjTL.getOriginalLoc();
+  }
+
   ArrayTypeLoc SrcATL = SrcTL.castAs<ArrayTypeLoc>();
   ArrayTypeLoc DstATL = DstTL.castAs<ArrayTypeLoc>();
   TypeLoc SrcElemTL = SrcATL.getElementLoc();
diff --git a/clang/lib/Sema/SemaExpr.cpp b/clang/lib/Sema/SemaExpr.cpp
index 2842add2c..1d5bc314d 100644
--- a/clang/lib/Sema/SemaExpr.cpp
+++ b/clang/lib/Sema/SemaExpr.cpp
@@ -4267,6 +4267,15 @@ bool Sema::CheckUnaryExprOrTypeTraitOperand(Expr *E,
   bool IsUnevaluatedOperand =
       (ExprKind == UETT_SizeOf || ExprKind == UETT_AlignOf ||
        ExprKind == UETT_PreferredAlignOf || ExprKind == UETT_VecStep);
+
+  // PASTA PATCH: Add in XNU-specific unary expr/type traits.
+  IsUnevaluatedOperand =
+      IsUnevaluatedOperand ||
+      ExprKind == UETT_PtrAuthTypeDiscriminator ||
+      ExprKind == UETT_XNUTypeSignature ||
+      ExprKind == UETT_XNUTypeSummary ||
+      ExprKind == UETT_TMOTypeGetMetadata;
+
   if (IsUnevaluatedOperand) {
     ExprResult Result = CheckUnevaluatedOperand(E);
     if (Result.isInvalid())
@@ -4637,8 +4646,14 @@ Sema::CreateUnaryExprOrTypeTraitExpr(TypeSourceInfo *TInfo,
       TInfo->getType()->isVariablyModifiedType())
     TInfo = TransformToPotentiallyEvaluated(TInfo);
 
+  // PASTA PATCH: This returns a string literal that is a type signature.
+  QualType RetTy = Context.getSizeType();
+  if (ExprKind == UETT_XNUTypeSignature) {
+    RetTy = Context.getStringLiteralArrayType(Context.CharTy, 0u);
+  }
+
   return new (Context) UnaryExprOrTypeTraitExpr(
-      ExprKind, TInfo, Context.getSizeType(), OpLoc, R.getEnd());
+      ExprKind, TInfo, RetTy, OpLoc, R.getEnd());
 }
 
 /// Build a sizeof or alignof expression given an expression
@@ -4652,6 +4667,9 @@ Sema::CreateUnaryExprOrTypeTraitExpr(Expr *E, SourceLocation OpLoc,
 
   E = PE.get();
 
+  // PASTA PATCH: We want a string literal array return type for the signature.
+  QualType RetTy = Context.getSizeType();
+
   // Verify that the operand is valid.
   bool isInvalid = false;
   if (E->isTypeDependent()) {
@@ -4666,6 +4684,16 @@ Sema::CreateUnaryExprOrTypeTraitExpr(Expr *E, SourceLocation OpLoc,
   } else if (E->refersToBitField()) {  // C99 6.5.3.4p1.
     Diag(E->getExprLoc(), diag::err_sizeof_alignof_typeof_bitfield) << 0;
     isInvalid = true;
+
+  // PASTA PATCH: Let these through.
+  } else if (ExprKind == UETT_PtrAuthTypeDiscriminator ||
+             ExprKind == UETT_XNUTypeSummary ||
+             ExprKind == UETT_TMOTypeGetMetadata) {
+
+  // PASTA PATCH: This returns a string literal that is a type signature.
+  } else if (ExprKind == UETT_XNUTypeSignature) {
+    RetTy = Context.getStringLiteralArrayType(Context.CharTy, 0u);
+
   } else {
     isInvalid = CheckUnaryExprOrTypeTraitOperand(E, UETT_SizeOf);
   }
@@ -4681,7 +4709,7 @@ Sema::CreateUnaryExprOrTypeTraitExpr(Expr *E, SourceLocation OpLoc,
 
   // C99 6.5.3.4p4: the type (an unsigned integer type) is size_t.
   return new (Context) UnaryExprOrTypeTraitExpr(
-      ExprKind, E, Context.getSizeType(), OpLoc, E->getSourceRange().getEnd());
+      ExprKind, E, RetTy, OpLoc, E->getSourceRange().getEnd());
 }
 
 /// ActOnUnaryExprOrTypeTraitExpr - Handle @c sizeof(type) and @c sizeof @c
diff --git a/clang/lib/Sema/SemaExprCXX.cpp b/clang/lib/Sema/SemaExprCXX.cpp
index abf5a72e7..f6eb0ca11 100644
--- a/clang/lib/Sema/SemaExprCXX.cpp
+++ b/clang/lib/Sema/SemaExprCXX.cpp
@@ -5654,6 +5654,7 @@ static bool EvaluateBinaryTypeTrait(Sema &Self, TypeTrait BTT, QualType LhsT,
   }
   case BTT_IsSame:
     return Self.Context.hasSameType(LhsT, RhsT);
+  case BTT_XNUTypeCompatible:  // PASTA PATCH
   case BTT_TypeCompatible: {
     // GCC ignores cv-qualifiers on arrays for this builtin.
     Qualifiers LhsQuals, RhsQuals;
diff --git a/clang/lib/Sema/TreeTransform.h b/clang/lib/Sema/TreeTransform.h
index 48bb28b56..8e3243b86 100644
--- a/clang/lib/Sema/TreeTransform.h
+++ b/clang/lib/Sema/TreeTransform.h
@@ -5309,6 +5309,12 @@ TreeTransform<Derived>::TransformConstantArrayType(TypeLocBuilder &TLB,
       return QualType();
   }
 
+  // PASTA PATCH: We might be dealing with an adjusted type due to Multiplier
+  //              issue #130.
+  if (auto AT = dyn_cast<AdjustedType>(Result.getTypePtr())) {
+    Result = AT->getAdjustedType();
+  }
+
   // We might have either a ConstantArrayType or a VariableArrayType now:
   // a ConstantArrayType is allowed to have an element type which is a
   // VariableArrayType if the type is dependent.  Fortunately, all array
@@ -5341,6 +5347,12 @@ QualType TreeTransform<Derived>::TransformIncompleteArrayType(
       return QualType();
   }
 
+  // PASTA PATCH: We might be dealing with an adjusted type due to Multiplier
+  //              issue #130.
+  if (auto AT = dyn_cast<AdjustedType>(Result.getTypePtr())) {
+    Result = AT->getAdjustedType();
+  }
+
   IncompleteArrayTypeLoc NewTL = TLB.push<IncompleteArrayTypeLoc>(Result);
   NewTL.setLBracketLoc(TL.getLBracketLoc());
   NewTL.setRBracketLoc(TL.getRBracketLoc());
@@ -5386,6 +5398,12 @@ TreeTransform<Derived>::TransformVariableArrayType(TypeLocBuilder &TLB,
       return QualType();
   }
 
+  // PASTA PATCH: We might be dealing with an adjusted type due to Multiplier
+  //              issue #130.
+  if (auto AT = dyn_cast<AdjustedType>(Result.getTypePtr())) {
+    Result = AT->getAdjustedType();
+  }
+
   // We might have constant size array now, but fortunately it has the same
   // location layout.
   ArrayTypeLoc NewTL = TLB.push<ArrayTypeLoc>(Result);
@@ -5434,6 +5452,12 @@ TreeTransform<Derived>::TransformDependentSizedArrayType(TypeLocBuilder &TLB,
       return QualType();
   }
 
+  // PASTA PATCH: We might be dealing with an adjusted type due to Multiplier
+  //              issue #130.
+  if (auto AT = dyn_cast<AdjustedType>(Result.getTypePtr())) {
+    Result = AT->getAdjustedType();
+  }
+
   // We might have any sort of array type now, but fortunately they
   // all have the same location layout.
   ArrayTypeLoc NewTL = TLB.push<ArrayTypeLoc>(Result);
-- 
2.40.0
