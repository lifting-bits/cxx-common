From 32fbac48f39e9fc24263495de5ca0b7df2d4c366 Mon Sep 17 00:00:00 2001
From: Brent Pappas <pappasbrent@gmail.com>
Date: Fri, 14 Jul 2023 14:34:09 -0400
Subject: [PATCH] UnknownAttrsAsAnnotate and AttributedType Attrs

- Adds the flag `funknown-attrs-as-annotate` to Clang to treat unknown
  attributes as annotate attributes by default.
- Adds a an `const Attr *` field to `AttributedType` to store the actual
  `Attr` that the type is attributed with, along with methods to access
  it.

Co-authored-by: Laura Bauman <laurabauman12@gmail.com>
---
 clang/include/clang/AST/ASTContext.h      |  3 +-
 clang/include/clang/AST/Type.h            | 17 ++++++++--
 clang/include/clang/Basic/LangOptions.def |  2 ++
 clang/include/clang/Driver/Options.td     |  5 +++
 clang/lib/AST/ASTContext.cpp              | 22 +++++++------
 clang/lib/AST/ASTImporter.cpp             |  4 ++-
 clang/lib/AST/Type.cpp                    |  5 +--
 clang/lib/Driver/ToolChains/Clang.cpp     |  5 +++
 clang/lib/Parse/ParseDeclCXX.cpp          | 24 ++++++++------
 clang/lib/Sema/SemaDeclAttr.cpp           | 25 +++++++++++++--
 clang/lib/Sema/SemaType.cpp               | 38 ++++++++++++++++++-----
 clang/lib/Sema/TreeTransform.h            |  5 ++-
 12 files changed, 116 insertions(+), 39 deletions(-)

diff --git a/clang/include/clang/AST/ASTContext.h b/clang/include/clang/AST/ASTContext.h
index 023837192..6cd459359 100644
--- a/clang/include/clang/AST/ASTContext.h
+++ b/clang/include/clang/AST/ASTContext.h
@@ -1582,7 +1582,8 @@ public:
   QualType getInjectedClassNameType(CXXRecordDecl *Decl, QualType TST) const;
 
   QualType getAttributedType(attr::Kind attrKind, QualType modifiedType,
-                             QualType equivalentType) const;
+                             QualType equivalentType,
+                             const Attr *typeAttr = nullptr) const;
 
   QualType getBTFTagAttributedType(const BTFTypeTagAttr *BTFAttr,
                                    QualType Wrapped);
diff --git a/clang/include/clang/AST/Type.h b/clang/include/clang/AST/Type.h
index 180251d7f..670e6f20d 100644
--- a/clang/include/clang/AST/Type.h
+++ b/clang/include/clang/AST/Type.h
@@ -56,6 +56,7 @@
 
 namespace clang {
 
+class Attr;
 class BTFTypeTagAttr;
 class ExtQuals;
 class QualType;
@@ -4880,13 +4881,14 @@ public:
 private:
   friend class ASTContext; // ASTContext creates these
 
+  const Attr *TypeAttr;
   QualType ModifiedType;
   QualType EquivalentType;
 
-  AttributedType(QualType canon, attr::Kind attrKind, QualType modified,
-                 QualType equivalent)
+  AttributedType(QualType canon, Kind attrKind, QualType modified,
+                 QualType equivalent, const Attr *typeAttr = nullptr)
       : Type(Attributed, canon, equivalent->getDependence()),
-        ModifiedType(modified), EquivalentType(equivalent) {
+        TypeAttr(typeAttr), ModifiedType(modified), EquivalentType(equivalent) {
     AttributedTypeBits.AttrKind = attrKind;
   }
 
@@ -4895,6 +4897,8 @@ public:
     return static_cast<Kind>(AttributedTypeBits.AttrKind);
   }
 
+  bool hasAttr() const { return TypeAttr != nullptr; }
+  const Attr *getAttr() const { return TypeAttr; }
   QualType getModifiedType() const { return ModifiedType; }
   QualType getEquivalentType() const { return EquivalentType; }
 
@@ -4958,6 +4962,13 @@ public:
     Profile(ID, getAttrKind(), ModifiedType, EquivalentType);
   }
 
+  static void Profile(llvm::FoldingSetNodeID &ID, const Attr *typeAttr,
+                      QualType modified, QualType equivalent) {
+    ID.AddPointer(typeAttr);
+    ID.AddPointer(modified.getAsOpaquePtr());
+    ID.AddPointer(equivalent.getAsOpaquePtr());
+  }
+
   static void Profile(llvm::FoldingSetNodeID &ID, Kind attrKind,
                       QualType modified, QualType equivalent) {
     ID.AddInteger(attrKind);
diff --git a/clang/include/clang/Basic/LangOptions.def b/clang/include/clang/Basic/LangOptions.def
index d1cbe4306..4b2240d57 100644
--- a/clang/include/clang/Basic/LangOptions.def
+++ b/clang/include/clang/Basic/LangOptions.def
@@ -311,6 +311,8 @@ LANGOPT(FastRelaxedMath , 1, 0, "OpenCL fast relaxed math")
 BENIGN_LANGOPT(CLNoSignedZero , 1, 0, "Permit Floating Point optimization without regard to signed zeros")
 COMPATIBLE_LANGOPT(CLUnsafeMath , 1, 0, "Unsafe Floating Point Math")
 COMPATIBLE_LANGOPT(CLFiniteMathOnly , 1, 0, "__FINITE_MATH_ONLY__ predefined macro")
+
+LANGOPT(UnknownAttrAnnotate, 1, 0, "Unknown attributes are treated as annotation or annotation type attributes during semantic analysis")
 /// FP_CONTRACT mode (on/off/fast).
 BENIGN_ENUM_LANGOPT(DefaultFPContractMode, FPModeKind, 2, FPM_Off, "FP contraction type")
 COMPATIBLE_LANGOPT(ExpStrictFP, 1, false, "Enable experimental strict floating point")
diff --git a/clang/include/clang/Driver/Options.td b/clang/include/clang/Driver/Options.td
index 652c15afc..64cb09a9a 100644
--- a/clang/include/clang/Driver/Options.td
+++ b/clang/include/clang/Driver/Options.td
@@ -4377,6 +4377,11 @@ def working_directory : Separate<["-"], "working-directory">, Flags<[CC1Option]>
 def working_directory_EQ : Joined<["-"], "working-directory=">, Flags<[CC1Option]>,
   Alias<working_directory>;
 
+def funknown_attrs_as_annotate : Flag<["-"], "funknown-attrs-as-annotate">,
+  Flags<[CC1Option]>,
+  HelpText<"Treat unknown attributes as annotation or annotation type attributes in semantic analysis">,
+  MarshallingInfoFlag<LangOpts<"UnknownAttrAnnotate">>;
+
 // Double dash options, which are usually an alias for one of the previous
 // options.
 
diff --git a/clang/lib/AST/ASTContext.cpp b/clang/lib/AST/ASTContext.cpp
index 8054eb2e1..6fe6badff 100644
--- a/clang/lib/AST/ASTContext.cpp
+++ b/clang/lib/AST/ASTContext.cpp
@@ -3203,10 +3203,11 @@ QualType ASTContext::getFunctionTypeWithExceptionSpec(
 
   // Might have a calling-convention attribute.
   if (const auto *AT = dyn_cast<AttributedType>(Orig))
-    return getAttributedType(
-        AT->getAttrKind(),
-        getFunctionTypeWithExceptionSpec(AT->getModifiedType(), ESI),
-        getFunctionTypeWithExceptionSpec(AT->getEquivalentType(), ESI));
+      return getAttributedType(
+          AT->getAttrKind(),
+          getFunctionTypeWithExceptionSpec(AT->getModifiedType(), ESI),
+          getFunctionTypeWithExceptionSpec(AT->getEquivalentType(), ESI),
+          AT->getAttr());
 
   // Anything else must be a function type. Rebuild it with the new exception
   // specification.
@@ -4765,11 +4766,14 @@ QualType ASTContext::getUnresolvedUsingType(
   return QualType(newType, 0);
 }
 
-QualType ASTContext::getAttributedType(attr::Kind attrKind,
-                                       QualType modifiedType,
-                                       QualType equivalentType) const {
+QualType ASTContext::getAttributedType(
+  attr::Kind attrKind, QualType modifiedType,
+  QualType equivalentType, const Attr *typeAttr/* = nullptr */)const {
   llvm::FoldingSetNodeID id;
-  AttributedType::Profile(id, attrKind, modifiedType, equivalentType);
+  if (typeAttr)
+    AttributedType::Profile(id, typeAttr, modifiedType, equivalentType);
+  else
+    AttributedType::Profile(id, attrKind, modifiedType, equivalentType);
 
   void *insertPos = nullptr;
   AttributedType *type = AttributedTypes.FindNodeOrInsertPos(id, insertPos);
@@ -4777,7 +4781,7 @@ QualType ASTContext::getAttributedType(attr::Kind attrKind,
 
   QualType canon = getCanonicalType(equivalentType);
   type = new (*this, TypeAlignment)
-      AttributedType(canon, attrKind, modifiedType, equivalentType);
+      AttributedType(canon, attrKind, modifiedType, equivalentType, typeAttr);
 
   Types.push_back(type);
   AttributedTypes.InsertNode(type, insertPos);
diff --git a/clang/lib/AST/ASTImporter.cpp b/clang/lib/AST/ASTImporter.cpp
index 6f367ef05..f6bbaef71 100644
--- a/clang/lib/AST/ASTImporter.cpp
+++ b/clang/lib/AST/ASTImporter.cpp
@@ -1501,7 +1501,9 @@ ExpectedType ASTNodeImporter::VisitAttributedType(const AttributedType *T) {
     return ToEquivalentTypeOrErr.takeError();
 
   return Importer.getToContext().getAttributedType(T->getAttrKind(),
-      *ToModifiedTypeOrErr, *ToEquivalentTypeOrErr);
+                                                   *ToModifiedTypeOrErr,
+                                                   *ToEquivalentTypeOrErr,
+                                                   T->getAttr());
 }
 
 ExpectedType ASTNodeImporter::VisitTemplateTypeParmType(
diff --git a/clang/lib/AST/Type.cpp b/clang/lib/AST/Type.cpp
index 54e62a193..290fe9d5f 100644
--- a/clang/lib/AST/Type.cpp
+++ b/clang/lib/AST/Type.cpp
@@ -1158,7 +1158,7 @@ public:
       return QualType(T, 0);
 
     return Ctx.getAttributedType(T->getAttrKind(), modifiedType,
-                                 equivalentType);
+                                 equivalentType, T->getAttr());
   }
 
   QualType VisitSubstTemplateTypeParmType(const SubstTemplateTypeParmType *T) {
@@ -1461,7 +1461,8 @@ struct SubstObjCTypeArgsVisitor
 
     // Rebuild the attributed type.
     return Ctx.getAttributedType(newAttrType->getAttrKind(),
-                                 newAttrType->getModifiedType(), newEquivType);
+                                 newAttrType->getModifiedType(), newEquivType,
+                                 newAttrType->getAttr());
   }
 };
 
diff --git a/clang/lib/Driver/ToolChains/Clang.cpp b/clang/lib/Driver/ToolChains/Clang.cpp
index 77554aa2c..e5b59cbe3 100644
--- a/clang/lib/Driver/ToolChains/Clang.cpp
+++ b/clang/lib/Driver/ToolChains/Clang.cpp
@@ -4615,6 +4615,11 @@ void Clang::ConstructJob(Compilation &C, const JobAction &JA,
     }
   }
 
+  if (const Arg *A = Args.getLastArg(options::OPT_funknown_attrs_as_annotate)) {
+    CmdArgs.push_back("-funknown-attrs-as-annotate");
+    A->claim();
+  }
+
   if (IsOpenMPDevice) {
     // We have to pass the triple of the host if compiling for an OpenMP device.
     std::string NormalizedTriple =
diff --git a/clang/lib/Parse/ParseDeclCXX.cpp b/clang/lib/Parse/ParseDeclCXX.cpp
index 227c1df2b..4d13a9b6a 100644
--- a/clang/lib/Parse/ParseDeclCXX.cpp
+++ b/clang/lib/Parse/ParseDeclCXX.cpp
@@ -4368,18 +4368,22 @@ bool Parser::ParseCXX11AttributeArgs(
       Syntax = ParsedAttr::AS_Microsoft;
   }
 
+
   // If the attribute isn't known, we will not attempt to parse any
-  // arguments.
-  if (Syntax != ParsedAttr::AS_Microsoft &&
-      !hasAttribute(LO.CPlusPlus ? AttributeCommonInfo::Syntax::AS_CXX11
-                                 : AttributeCommonInfo::Syntax::AS_C2x,
-                    ScopeName, AttrName, getTargetInfo(), getLangOpts())) {
-    if (getLangOpts().MicrosoftExt || getLangOpts().HLSL) {
+  // arguments. Unless we are treating unknown attributes as annotation
+  // attributes.
+  if (!getLangOpts().UnknownAttrAnnotate) {
+    if (Syntax != ParsedAttr::AS_Microsoft &&
+        !hasAttribute(LO.CPlusPlus ? AttributeCommonInfo::Syntax::AS_CXX11
+                                  : AttributeCommonInfo::Syntax::AS_C2x,
+                      ScopeName, AttrName, getTargetInfo(), getLangOpts())) {
+      if (getLangOpts().MicrosoftExt || getLangOpts().HLSL) {
+      }
+      // Eat the left paren, then skip to the ending right paren.
+      ConsumeParen();
+      SkipUntil(tok::r_paren);
+      return false;
     }
-    // Eat the left paren, then skip to the ending right paren.
-    ConsumeParen();
-    SkipUntil(tok::r_paren);
-    return false;
   }
 
   if (ScopeName && (ScopeName->isStr("gnu") || ScopeName->isStr("__gnu__"))) {
diff --git a/clang/lib/Sema/SemaDeclAttr.cpp b/clang/lib/Sema/SemaDeclAttr.cpp
index a303c7f57..228b54a61 100644
--- a/clang/lib/Sema/SemaDeclAttr.cpp
+++ b/clang/lib/Sema/SemaDeclAttr.cpp
@@ -4285,6 +4285,21 @@ static void handleAnnotateAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
   S.AddAnnotationAttr(D, AL, Str, Args);
 }
 
+static void
+handleUnknownAttrAsAnnotateAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
+  // Get name of unknown attribute:
+  StringRef Str = AL.getAttrName()->getName();
+
+  llvm::SmallVector<Expr *, 4> Args;
+  Args.reserve(AL.getNumArgs());
+    for (unsigned Idx = 0; Idx < AL.getNumArgs(); Idx++) {
+    assert(!AL.isArgIdent(Idx));
+    Args.push_back(AL.getArgAsExpr(Idx));
+  }
+
+  S.AddAnnotationAttr(D, AL, Str, Args);
+}
+
 static void handleAlignValueAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
   S.AddAlignValueAttr(D, AL, AL.getArgAsExpr(0));
 }
@@ -8594,11 +8609,15 @@ ProcessDeclAttribute(Sema &S, Scope *scope, Decl *D, const ParsedAttr &AL,
   // though they were unknown attributes.
   if (AL.getKind() == ParsedAttr::UnknownAttribute ||
       !AL.existsInTarget(S.Context.getTargetInfo())) {
-    S.Diag(AL.getLoc(),
-           AL.isDeclspecAttribute()
+        if (S.getLangOpts().UnknownAttrAnnotate) {
+          handleUnknownAttrAsAnnotateAttr(S, D, AL);
+        } else {
+          S.Diag(AL.getLoc(),
+            AL.isDeclspecAttribute()
                ? (unsigned)diag::warn_unhandled_ms_attribute_ignored
                : (unsigned)diag::warn_unknown_attribute_ignored)
-        << AL << AL.getRange();
+            << AL << AL.getRange();
+        }
     return;
   }
 
diff --git a/clang/lib/Sema/SemaType.cpp b/clang/lib/Sema/SemaType.cpp
index 8cb1ed28f..7e60f4bce 100644
--- a/clang/lib/Sema/SemaType.cpp
+++ b/clang/lib/Sema/SemaType.cpp
@@ -257,7 +257,8 @@ namespace {
     QualType getAttributedType(Attr *A, QualType ModifiedType,
                                QualType EquivType) {
       QualType T =
-          sema.Context.getAttributedType(A->getKind(), ModifiedType, EquivType);
+        sema.Context.getAttributedType(A->getKind(), ModifiedType, EquivType,
+                                       A);
       AttrsForTypes.push_back({cast<AttributedType>(T.getTypePtr()), A});
       AttrsForTypesSorted = false;
       return T;
@@ -8287,6 +8288,24 @@ static void HandleMatrixTypeAttr(QualType &CurType, const ParsedAttr &Attr,
     CurType = T;
 }
 
+static void HandleUnkownTypeAttrAsAnnotateTypeAttr(TypeProcessingState &State,
+                                   QualType &CurType, const ParsedAttr &PA) {
+  Sema &S = State.getSema();
+  StringRef Str = PA.getAttrName()->getName();
+
+  llvm::SmallVector<Expr *, 4> Args;
+  Args.reserve(PA.getNumArgs());
+  for (unsigned Idx = 0; Idx < PA.getNumArgs(); Idx++) {
+    assert(!PA.isArgIdent(Idx));
+    Args.push_back(PA.getArgAsExpr(Idx));
+  }
+  if (!S.ConstantFoldAttrArgs(PA, Args))
+    return;
+  auto *AnnotateTypeAttr =
+      AnnotateTypeAttr::Create(S.Context, Str, Args.data(), Args.size(), PA);
+  CurType = State.getAttributedType(AnnotateTypeAttr, CurType, CurType);
+}
+
 static void HandleAnnotateTypeAttr(TypeProcessingState &State,
                                    QualType &CurType, const ParsedAttr &PA) {
   Sema &S = State.getSema();
@@ -8390,12 +8409,17 @@ static void processTypeAttrs(TypeProcessingState &state, QualType &type,
 
     case ParsedAttr::UnknownAttribute:
       if (attr.isStandardAttributeSyntax()) {
-        state.getSema().Diag(attr.getLoc(),
-                             diag::warn_unknown_attribute_ignored)
-            << attr << attr.getRange();
-        // Mark the attribute as invalid so we don't emit the same diagnostic
-        // multiple times.
-        attr.setInvalid();
+        if (state.getSema().getLangOpts().UnknownAttrAnnotate) {
+          HandleUnkownTypeAttrAsAnnotateTypeAttr(state, type, attr);
+          attr.setUsedAsTypeAttr();
+        } else {
+          state.getSema().Diag(attr.getLoc(),
+                                diag::warn_unknown_attribute_ignored)
+                                << attr << attr.getRange();
+          // Mark the attribute as invalid so we don't emit the same diagnostic
+          // multiple times.
+          attr.setInvalid();
+        }
       }
       break;
 
diff --git a/clang/lib/Sema/TreeTransform.h b/clang/lib/Sema/TreeTransform.h
index 4244bbc1e..fbfff5404 100644
--- a/clang/lib/Sema/TreeTransform.h
+++ b/clang/lib/Sema/TreeTransform.h
@@ -6995,9 +6995,8 @@ QualType TreeTransform<Derived>::TransformAttributedType(
       }
     }
 
-    result = SemaRef.Context.getAttributedType(TL.getAttrKind(),
-                                               modifiedType,
-                                               equivalentType);
+    result = SemaRef.Context.getAttributedType(TL.getAttrKind(), modifiedType,
+                                               equivalentType, TL.getAttr());
   }
 
   AttributedTypeLoc newTL = TLB.push<AttributedTypeLoc>(result);
-- 
2.34.1

