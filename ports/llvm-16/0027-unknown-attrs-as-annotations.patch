From b3b2b93d3d0e28e2d1269c3fcbb8a509c2331858 Mon Sep 17 00:00:00 2001
From: Peter Goodman <peter.goodman@gmail.com>
Date: Fri, 24 Mar 2023 16:58:52 -0400
Subject: [PATCH] Patches for supporting arbitrary attributes as annotation
 attributes

---
 clang/include/clang/Basic/LangOptions.def |  2 ++
 clang/include/clang/Driver/Options.td     |  5 ++++
 clang/lib/Driver/ToolChains/Clang.cpp     |  5 ++++
 clang/lib/Parse/ParseDeclCXX.cpp          | 24 +++++++++-------
 clang/lib/Sema/SemaDeclAttr.cpp           | 25 ++++++++++++++--
 clang/lib/Sema/SemaType.cpp               | 35 +++++++++++++++++++----
 6 files changed, 77 insertions(+), 19 deletions(-)

diff --git a/clang/include/clang/Basic/LangOptions.def b/clang/include/clang/Basic/LangOptions.def
index d1cbe4306..4b2240d57 100644
--- a/clang/include/clang/Basic/LangOptions.def
+++ b/clang/include/clang/Basic/LangOptions.def
@@ -311,6 +311,8 @@ LANGOPT(FastRelaxedMath , 1, 0, "OpenCL fast relaxed math")
 BENIGN_LANGOPT(CLNoSignedZero , 1, 0, "Permit Floating Point optimization without regard to signed zeros")
 COMPATIBLE_LANGOPT(CLUnsafeMath , 1, 0, "Unsafe Floating Point Math")
 COMPATIBLE_LANGOPT(CLFiniteMathOnly , 1, 0, "__FINITE_MATH_ONLY__ predefined macro")
+
+LANGOPT(UnknownAttrAnnotate, 1, 0, "Unknown attributes are treated as annotation or annotation type attributes during semantic analysis")
 /// FP_CONTRACT mode (on/off/fast).
 BENIGN_ENUM_LANGOPT(DefaultFPContractMode, FPModeKind, 2, FPM_Off, "FP contraction type")
 COMPATIBLE_LANGOPT(ExpStrictFP, 1, false, "Enable experimental strict floating point")
diff --git a/clang/include/clang/Driver/Options.td b/clang/include/clang/Driver/Options.td
index 652c15afc..64cb09a9a 100644
--- a/clang/include/clang/Driver/Options.td
+++ b/clang/include/clang/Driver/Options.td
@@ -4377,6 +4377,11 @@ def working_directory : Separate<["-"], "working-directory">, Flags<[CC1Option]>
 def working_directory_EQ : Joined<["-"], "working-directory=">, Flags<[CC1Option]>,
   Alias<working_directory>;
 
+def funknown_attrs_as_annotate : Flag<["-"], "funknown-attrs-as-annotate">,
+  Flags<[CC1Option]>,
+  HelpText<"Treat unknown attributes as annotation or annotation type attributes in semantic analysis">,
+  MarshallingInfoFlag<LangOpts<"UnknownAttrAnnotate">>;
+
 // Double dash options, which are usually an alias for one of the previous
 // options.
 
diff --git a/clang/lib/Driver/ToolChains/Clang.cpp b/clang/lib/Driver/ToolChains/Clang.cpp
index ec6860113..02746500d 100644
--- a/clang/lib/Driver/ToolChains/Clang.cpp
+++ b/clang/lib/Driver/ToolChains/Clang.cpp
@@ -4615,6 +4615,11 @@ void Clang::ConstructJob(Compilation &C, const JobAction &JA,
     }
   }
 
+  if (const Arg *A = Args.getLastArg(options::OPT_funknown_attrs_as_annotate)) {
+    CmdArgs.push_back("-funknown-attrs-as-annotate");
+    A->claim();
+  }
+
   if (IsOpenMPDevice) {
     // We have to pass the triple of the host if compiling for an OpenMP device.
     std::string NormalizedTriple =
diff --git a/clang/lib/Parse/ParseDeclCXX.cpp b/clang/lib/Parse/ParseDeclCXX.cpp
index 227c1df2b..4d13a9b6a 100644
--- a/clang/lib/Parse/ParseDeclCXX.cpp
+++ b/clang/lib/Parse/ParseDeclCXX.cpp
@@ -4368,18 +4368,22 @@ bool Parser::ParseCXX11AttributeArgs(
       Syntax = ParsedAttr::AS_Microsoft;
   }
 
+
   // If the attribute isn't known, we will not attempt to parse any
-  // arguments.
-  if (Syntax != ParsedAttr::AS_Microsoft &&
-      !hasAttribute(LO.CPlusPlus ? AttributeCommonInfo::Syntax::AS_CXX11
-                                 : AttributeCommonInfo::Syntax::AS_C2x,
-                    ScopeName, AttrName, getTargetInfo(), getLangOpts())) {
-    if (getLangOpts().MicrosoftExt || getLangOpts().HLSL) {
+  // arguments. Unless we are treating unknown attributes as annotation
+  // attributes.
+  if (!getLangOpts().UnknownAttrAnnotate) {
+    if (Syntax != ParsedAttr::AS_Microsoft &&
+        !hasAttribute(LO.CPlusPlus ? AttributeCommonInfo::Syntax::AS_CXX11
+                                  : AttributeCommonInfo::Syntax::AS_C2x,
+                      ScopeName, AttrName, getTargetInfo(), getLangOpts())) {
+      if (getLangOpts().MicrosoftExt || getLangOpts().HLSL) {
+      }
+      // Eat the left paren, then skip to the ending right paren.
+      ConsumeParen();
+      SkipUntil(tok::r_paren);
+      return false;
     }
-    // Eat the left paren, then skip to the ending right paren.
-    ConsumeParen();
-    SkipUntil(tok::r_paren);
-    return false;
   }
 
   if (ScopeName && (ScopeName->isStr("gnu") || ScopeName->isStr("__gnu__"))) {
diff --git a/clang/lib/Sema/SemaDeclAttr.cpp b/clang/lib/Sema/SemaDeclAttr.cpp
index a303c7f57..228b54a61 100644
--- a/clang/lib/Sema/SemaDeclAttr.cpp
+++ b/clang/lib/Sema/SemaDeclAttr.cpp
@@ -4285,6 +4285,21 @@ static void handleAnnotateAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
   S.AddAnnotationAttr(D, AL, Str, Args);
 }
 
+static void
+handleUnknownAttrAsAnnotateAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
+  // Get name of unknown attribute:
+  StringRef Str = AL.getAttrName()->getName();
+
+  llvm::SmallVector<Expr *, 4> Args;
+  Args.reserve(AL.getNumArgs());
+    for (unsigned Idx = 0; Idx < AL.getNumArgs(); Idx++) {
+    assert(!AL.isArgIdent(Idx));
+    Args.push_back(AL.getArgAsExpr(Idx));
+  }
+
+  S.AddAnnotationAttr(D, AL, Str, Args);
+}
+
 static void handleAlignValueAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
   S.AddAlignValueAttr(D, AL, AL.getArgAsExpr(0));
 }
@@ -8594,11 +8609,15 @@ ProcessDeclAttribute(Sema &S, Scope *scope, Decl *D, const ParsedAttr &AL,
   // though they were unknown attributes.
   if (AL.getKind() == ParsedAttr::UnknownAttribute ||
       !AL.existsInTarget(S.Context.getTargetInfo())) {
-    S.Diag(AL.getLoc(),
-           AL.isDeclspecAttribute()
+        if (S.getLangOpts().UnknownAttrAnnotate) {
+          handleUnknownAttrAsAnnotateAttr(S, D, AL);
+        } else {
+          S.Diag(AL.getLoc(),
+            AL.isDeclspecAttribute()
                ? (unsigned)diag::warn_unhandled_ms_attribute_ignored
                : (unsigned)diag::warn_unknown_attribute_ignored)
-        << AL << AL.getRange();
+            << AL << AL.getRange();
+        }
     return;
   }
 
diff --git a/clang/lib/Sema/SemaType.cpp b/clang/lib/Sema/SemaType.cpp
index 8cb1ed28f..909ed3d74 100644
--- a/clang/lib/Sema/SemaType.cpp
+++ b/clang/lib/Sema/SemaType.cpp
@@ -8287,6 +8287,24 @@ static void HandleMatrixTypeAttr(QualType &CurType, const ParsedAttr &Attr,
     CurType = T;
 }
 
+static void HandleUnkownTypeAttrAsAnnotateTypeAttr(TypeProcessingState &State,
+                                   QualType &CurType, const ParsedAttr &PA) {
+  Sema &S = State.getSema();
+  StringRef Str = PA.getAttrName()->getName();
+
+  llvm::SmallVector<Expr *, 4> Args;
+  Args.reserve(PA.getNumArgs());
+  for (unsigned Idx = 0; Idx < PA.getNumArgs(); Idx++) {
+    assert(!PA.isArgIdent(Idx));
+    Args.push_back(PA.getArgAsExpr(Idx));
+  }
+  if (!S.ConstantFoldAttrArgs(PA, Args))
+    return;
+  auto *AnnotateTypeAttr =
+      AnnotateTypeAttr::Create(S.Context, Str, Args.data(), Args.size(), PA);
+  CurType = State.getAttributedType(AnnotateTypeAttr, CurType, CurType);
+}
+
 static void HandleAnnotateTypeAttr(TypeProcessingState &State,
                                    QualType &CurType, const ParsedAttr &PA) {
   Sema &S = State.getSema();
@@ -8390,12 +8408,17 @@ static void processTypeAttrs(TypeProcessingState &state, QualType &type,
 
     case ParsedAttr::UnknownAttribute:
       if (attr.isStandardAttributeSyntax()) {
-        state.getSema().Diag(attr.getLoc(),
-                             diag::warn_unknown_attribute_ignored)
-            << attr << attr.getRange();
-        // Mark the attribute as invalid so we don't emit the same diagnostic
-        // multiple times.
-        attr.setInvalid();
+        if (state.getSema().getLangOpts().UnknownAttrAnnotate) {
+          HandleUnkownTypeAttrAsAnnotateTypeAttr(state, type, attr);
+          attr.setUsedAsTypeAttr();
+        } else {
+          state.getSema().Diag(attr.getLoc(),
+                                diag::warn_unknown_attribute_ignored)
+                                << attr << attr.getRange();
+          // Mark the attribute as invalid so we don't emit the same diagnostic
+          // multiple times.
+          attr.setInvalid();
+        }
       }
       break;
 
-- 
2.39.0

